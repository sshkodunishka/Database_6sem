SET ECHO ON
SET VERIFY ON
SET FEEDBACK ON
SET DEFINE ON
CLEAR SCREEN
set serveroutput on

COLUMN date_time NEW_VAL filename noprint;
SELECT to_char(systimestamp,'yyyy-mm-dd_hh24-mi-ssxff') date_time FROM DUAL;
spool "lab6_2_&filename..log"

-- Password file execution
@passworddefinition.sql

PROMPT Dropping Role ROLE_lab6_2 ...
DROP ROLE ROLE_lab6_2 ;
PROMPT Creating Role ROLE_lab6_2 ...
CREATE ROLE ROLE_lab6_2 ;

-- PROMPT Drop TravelAgency user
-- drop user TravelAgency cascade;
   
PROMPT Create user TravelAgency
CREATE USER TravelAgency IDENTIFIED BY &&TravelAgency_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */;
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO TravelAgency;

-- PROMPT Drop Emulation user
-- drop user Emulation cascade;
   
PROMPT Create user Emulation
CREATE USER Emulation IDENTIFIED BY &&Emulation_password PASSWORD EXPIRE ACCOUNT LOCK /* DEFAULT TABLESPACE USERS  TEMPORARY TABLESPACE TEMP */;
GRANT CREATE SESSION, RESOURCE, CREATE VIEW, CREATE MATERIALIZED VIEW, CREATE SYNONYM, UNLIMITED TABLESPACE TO Emulation;

set define on
prompt connecting to Emulation
alter session set current_schema=Emulation;
set define off
create PACKAGE UTILS AS
SQLSERVER           VARCHAR2(10)  := 'SQLSERVER';
SYBASE              VARCHAR2(10)  := 'SYBASE';
DATABASE_TYPE       VARCHAR2(10)  :=  SQLSERVER;

IDENTITY_VALUE   NUMBER(10);
TRANCOUNT  NUMBER(10):=0;
VAR_NUMBER NUMBER(10):=0;
SUBTYPE ts is timestamp(9) ;
SUBTYPE tstz is timestamp(9) with time zone;

TYPE IDENTITY_TYPE IS TABLE OF NUMBER INDEX BY VARCHAR2(200);
identitymap identity_type;
FUNCTION  IDENTITY( V_IDENTITYID VARCHAR2, V_SEED INT DEFAULT 1,V_INCREMENT  INT DEFAULT 1) RETURN NUMBER;
PROCEDURE IDENTITY_RESET( V_IDENTITYID VARCHAR2);

FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2;
FUNCTION BIGINTTOHEX(P_EXPR RAW)    RETURN VARCHAR2;

FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;

FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER;

FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW)    RETURN RAW;
FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER;
FUNCTION BIT_AND(P_NUM1 NUMBER   ,P_RAW1 RAW) RETURN RAW;
FUNCTION BIT_AND(P_RAW1 RAW,P_NUM1 NUMBER) RETURN RAW;

FUNCTION BIT_COMPLIMENT(P_RAW1 RAW )    RETURN RAW;
FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER;

FUNCTION CONVERT_TO_BLOB    (P_EXPR IN VARCHAR2                 ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;
FUNCTION CONVERT_TO_BLOB    (P_EXPR IN NUMBER                   ,P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0     ,P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB;

FUNCTION CONVERT_TO_RAW     (P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN RAW;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_DATE	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;

FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;

FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;
FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE;

FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN VARCHAR2	                 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN DATE	                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TS	               , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;
FUNCTION CONVERT_TO_TIMESTAMP	      (P_EXPR IN TSTZ	 , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;
FUNCTION CONVERT_TO_NUMBER  (P_BLOB_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;
FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2;
FUNCTION CONVERT_TO_VARCHAR2  (P_EXPR IN BLOB                     , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0)    RETURN VARCHAR2;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;
FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                    , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB;

FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TS)  RETURN VARCHAR2;
FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ)  RETURN VARCHAR2;

FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_STR IN VARCHAR2)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN DATE)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TS)  RETURN NUMBER;
FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ) RETURN NUMBER;

FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_STR IN VARCHAR2) RETURN TS;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN DATE) RETURN DATE;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TS) RETURN TS;
FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TSTZ) RETURN TS;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TS) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TS) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TS) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TS) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TS) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN DATE) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER;

FUNCTION ZERODATETIME RETURN DATE;

FUNCTION YEAR_(P_DATE_STR    IN VARCHAR2) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN DATE) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN TS) RETURN NUMBER;
FUNCTION YEAR_(P_DATE_EXPR   IN TSTZ) RETURN NUMBER;

FUNCTION MONTH_(P_DATE_STR  IN VARCHAR2) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN DATE) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN TS) RETURN NUMBER;
FUNCTION MONTH_(P_DATE_EXPR  IN TSTZ) RETURN NUMBER;

FUNCTION DAY_(P_DATE_STR     IN VARCHAR2) RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN DATE)     RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN TS) RETURN NUMBER;
FUNCTION DAY_(P_DATE_EXPR    IN TSTZ) RETURN NUMBER;

FUNCTION STUFF(P_EXPR VARCHAR2, P_STARTIDX NUMBER, P_LEN NUMBER, P_REPLACE_EXPR VARCHAR2)  RETURN VARCHAR2;
FUNCTION REVERSE_(P_EXPR IN VARCHAR2)                                                      RETURN VARCHAR2;
FUNCTION QUOTENAME(P_STR IN VARCHAR2, P_DELIMITERS IN VARCHAR2 DEFAULT '[]')               RETURN VARCHAR2;
FUNCTION PARSENAME(P_OBJECT_NAME IN VARCHAR2, P_OBJECT_PIECE IN NUMBER)                    RETURN VARCHAR2;
FUNCTION DIFFERENCE(P_EXPR1 IN VARCHAR2, P_EXPR2 IN VARCHAR2)                              RETURN NUMBER;
FUNCTION PATINDEX(P_PATTERN IN VARCHAR2, P_EXPR IN VARCHAR2, P_FORMAT IN VARCHAR2 DEFAULT 'USING CHARS') RETURN NUMBER;
 
--NOTE THESE ALL NEED TO BE OVERRIDDEN WITH TIMESTAMP,TIMESTAMP TZ AND DATE DATA TYPES . LETS TEST REST FIRST
FUNCTION STATS_DATE(P_TABLE IN VARCHAR2,  P_INDEX IN VARCHAR2) RETURN DATE;

FUNCTION ISDATE(P_EXPR      IN VARCHAR2) RETURN NUMBER;
FUNCTION ISNUMERIC(P_EXPR IN VARCHAR2)       RETURN NUMBER;
FUNCTION DEGREES(P_ANGLE_RADIANS IN NUMBER)  RETURN NUMBER;
FUNCTION RADIANS(P_DEGREE IN NUMBER)         RETURN NUMBER;
FUNCTION ROUND_(P_EXPR NUMBER, P_LEN NUMBER, P_FUNCTION NUMBER DEFAULT 0)  RETURN NUMBER;
FUNCTION RAND(P_SEED NUMBER DEFAULT NULL)    RETURN NUMBER;
FUNCTION OCT(P_NUM VARCHAR2)                 RETURN VARCHAR2;
FUNCTION HEX(P_NUM VARCHAR2)                 RETURN VARCHAR2;
FUNCTION TO_BASE(P_DEC NUMBER, P_BASE NUMBER)RETURN VARCHAR2;
FUNCTION TO_SECOND(P_TIME VARCHAR2) RETURN NUMBER;

FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2;
FUNCTION PI RETURN NUMBER;

PROCEDURE COMMIT_TRANSACTION;
FUNCTION  COMMIT_TRANSACTION_STATE RETURN NUMBER;
PROCEDURE RESETTRANCOUNT;
PROCEDURE DECREMENTTRANCOUNT;
PROCEDURE INCREMENTTRANCOUNT;
FUNCTION GETIDENTITY RETURN NUMBER;
FUNCTION IDENT_INCR(P_SEQUENCE IN VARCHAR2)     RETURN NUMBER;
FUNCTION FETCH_STATUS(P_CURSORFOUND IN BOOLEAN) RETURN NUMBER;
FUNCTION SQLSTATUS(P_CURSORFOUND IN BOOLEAN,P_CURSOROPEN IN BOOLEAN) RETURN NUMBER;
FUNCTION IDENT_SEED(P_SEQUENCE IN VARCHAR2) RETURN NUMBER;
FUNCTION SPID RETURN NUMBER;
PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2);

FUNCTION LICENSE_ENABLED(SERVER IN VARCHAR2 DEFAULT 'ase_server') RETURN PLS_INTEGER;
FUNCTION OBJECT_ID(OBJECTREF VARCHAR2) RETURN INT;
PROCEDURE RAISERROR(ERRORCODE NUMBER,MSG VARCHAR2);
PROCEDURE HANDLEERROR(ERRORCODE NUMBER,MSG VARCHAR2);
FUNCTION error_line      RETURN VARCHAR2;
FUNCTION error_procedure RETURN VARCHAR2;
FUNCTION error_severity  RETURN VARCHAR2;
FUNCTION error_state     RETURN VARCHAR2;
end utils;
/

create PACKAGE BODY UTILS AS

TYPE VARCHAR2_ARRAY IS TABLE OF VARCHAR2(100);
DT_FORMATS          VARCHAR2_ARRAY; -- Customer : Please Modify the List of Date/Timestamp Formats so that the most common T-SQL literals are at the top
DT_DAY              VARCHAR2_ARRAY; -- Datetime formats starting with Day
DT_MONTH            VARCHAR2_ARRAY; -- Datetime formats starting with Month
DT_YEAR             VARCHAR2_ARRAY; -- Datetime formats starting with Year
DT_TIME             VARCHAR2_ARRAY; -- Datetime formats just having Hour, Minute, Second and Fractional seconds
DT_NLS              VARCHAR2_ARRAY; -- Oracle NLS DateTime formats
DT_TIMESTAMP        VARCHAR2_ARRAY; -- Oracle TIMESTAMP formats

DEFAULT_CHAR_SIZE NUMBER := 30;    

FUNCTION ZERODATETIME RETURN DATE
IS
BEGIN
  RETURN TO_DATE('1900-01-01','yyyy-mm-dd');
END;

FUNCTION LICENSE_ENABLED 
(
  SERVER IN VARCHAR2 DEFAULT 'ase_server' 
) RETURN pls_integer AS 
RET_VAL NUMBER := 0;
BEGIN
  IF 
        (lower(SERVER) = 'ase_server' 
  OR lower(SERVER) = 'ase_ha' 
  OR lower(SERVER) = 'ase_dtm' 
  OR lower(SERVER) = 'ase_java' 
  OR lower(SERVER) = 'ase_asm')
  THEN return 1;
  ELSE return 0 ;
  END IF;
END LICENSE_ENABLED;
-- PRIVATE 
FUNCTION GET_FORMAT_FROM_STYLE(P_STYLE NUMBER) RETURN VARCHAR2
IS
V_FORMAT VARCHAR2(50);
BEGIN
IF DATABASE_TYPE = SYBASE THEN --http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.help.ase_15.0.blocks/html/blocks/blocks125.htm
V_FORMAT := CASE 

                WHEN P_STYLE = 0   THEN  'Mon DD YYYY HH12:MI AM'
                WHEN P_STYLE = 100 THEN  'Mon DD YYYY HH12:MI AM'
                WHEN P_STYLE = 1   THEN  'MM/DD/YY'
                WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
                WHEN P_STYLE = 2   THEN  'YY.MM.DD'
                WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
                WHEN P_STYLE = 3   THEN  'DD/MM/YY'
                WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
                WHEN P_STYLE = 4   THEN  'DD.MM.YY'
                WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
                WHEN P_STYLE = 5   THEN  'DD-MM-YY'
                WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
                WHEN P_STYLE = 6   THEN  'DD Mon YY'
                WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
                WHEN P_STYLE = 7   THEN  'Mon DD, YY'
                WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
                WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
                WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
                WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 10  THEN  'MM-DD-YY'
                WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
                WHEN P_STYLE = 11  THEN  'YY/MM/DD'
                WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
                WHEN P_STYLE = 12  THEN  'YYMMDD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 112 THEN  'YYYYMMDD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 13  THEN  'YY/DD/MM' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 113 THEN  'YYYY/DD/MM'
                WHEN P_STYLE = 14  THEN  'MM/YY/DD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 114 THEN  'MM/YYYY/DD' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 15  THEN  'DD/YY/MM'
                WHEN P_STYLE = 115 THEN  'DD/YYYY/MM'
                WHEN P_STYLE = 16  THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
                WHEN P_STYLE = 116 THEN  'Mon  fmDDfm YYYY HH24:MI:SS'
                WHEN P_STYLE = 17  THEN  'FMHH12:MIAM'
                WHEN P_STYLE = 117 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 18  THEN  'HH24:MI'
                WHEN P_STYLE = 118 THEN  'YYYY/MM/DD FMHH12:MIAM' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 19  THEN  'FMHH12:MI:SS:FF3AM'
                WHEN P_STYLE = 119 THEN  'FMHH12:MI:SS:FF3AM'        
                WHEN P_STYLE = 20  THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 120 THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 21  THEN  'YY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 121 THEN  'YYYY/MM/DD HH:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 22  THEN  'YY/MM/DD  fmHH:MIAM'
                WHEN P_STYLE = 122 THEN  'YYYY/MM/DD  fmHH:MIAM'
                WHEN P_STYLE = 23  THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                WHEN P_STYLE = 123 THEN  'YYYY-MM-DD"T"HH12:MI:SS' -- Different from the doc. Testing suggests this is the actual format
                END;
END IF;
IF DATABASE_TYPE = SQLSERVER THEN
V_FORMAT := CASE 
                WHEN P_STYLE = 0   THEN  'MON DD YYYY HH12:MIAM'
                WHEN P_STYLE = 100 THEN  'MON DD YYYY HH12:MIAM'
                WHEN P_STYLE = 1   THEN  'MM/DD/YY'
                WHEN P_STYLE = 101 THEN  'MM/DD/YYYY'
                WHEN P_STYLE = 2   THEN  'YY.MM.DD'
                WHEN P_STYLE = 102 THEN  'YYYY.MM.DD'
                WHEN P_STYLE = 3   THEN  'DD/MM/YY'
                WHEN P_STYLE = 103 THEN  'DD/MM/YYYY'
                WHEN P_STYLE = 4   THEN  'DD.MM.YY'
                WHEN P_STYLE = 104 THEN  'DD.MM.YYYY'
                WHEN P_STYLE = 5   THEN  'DD-MM-YY'
                WHEN P_STYLE = 105 THEN  'DD-MM-YYYY'
                WHEN P_STYLE = 6   THEN  'DD Mon YY'
                WHEN P_STYLE = 106 THEN  'DD Mon YYYY'
                WHEN P_STYLE = 7   THEN  'Mon DD, YY'
                WHEN P_STYLE = 107 THEN  'Mon DD, YYYY'
                WHEN P_STYLE = 8   THEN  'HH24:MI:SS'
                WHEN P_STYLE = 108 THEN  'HH24:MI:SS'
                WHEN P_STYLE = 9   THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 109 THEN  'FMMon  DD YYYY  HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 10  THEN  'MM-DD-YY'
                WHEN P_STYLE = 110 THEN  'MM-DD-YYYY'
                WHEN P_STYLE = 11  THEN  'YY/MM/DD'
                WHEN P_STYLE = 111 THEN  'YYYY/MM/DD'
                WHEN P_STYLE = 12  THEN  'YYMMDD'
                WHEN P_STYLE = 112 THEN  'YYYYMMDD'
                WHEN P_STYLE = 13  THEN  'DD Mon YYYY HH24:MI:SS:FF3'
                WHEN P_STYLE = 113 THEN  'DD Mon YYYY HH24:MI:SS:FF3'
                WHEN P_STYLE = 14  THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 114 THEN  'HH24:MI:SS:FF3'
                WHEN P_STYLE = 20  THEN  'YYYY-MM-DD HH24:MI:SS'
                WHEN P_STYLE = 120 THEN  'MM/DD/YY  HH12:MI:SS AM'
                WHEN P_STYLE = 21  THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
                WHEN P_STYLE = 22  THEN  'MM/DD/YY  FMHH12:MI:SS AM'
                WHEN P_STYLE = 122 THEN  'MM/DD/YY  FMHH12:MI:SS AM'
                WHEN P_STYLE = 23  THEN  'YYYY-MM-DD'
                WHEN P_STYLE = 123 THEN  'YYYY-MM-DD'
                WHEN P_STYLE = 121 THEN  'YYYY-MM-DD HH24:MI:SS.FF3'
                WHEN P_STYLE = 126 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
                WHEN P_STYLE = 127 THEN  'YYYY-MM-DD HH12:MI:SS.FF3'
                WHEN P_STYLE = 130 THEN  'DD Mon YYYY HH12:MI:SS:FF3AM'
                WHEN P_STYLE = 131 THEN  'DD/MM/YY HH12:MI:SS:FF3AM' 
                END;
END IF;

RETURN V_FORMAT;                
END;

FUNCTION CONVERT_STRING_TO_TIMESTAMP (ARG VARCHAR2) RETURN TS
  AS
  BEGIN
   FOR i in DT_FORMATS.FIRST .. DT_FORMATS.LAST
   LOOP
    BEGIN
      RETURN TO_TIMESTAMP(ARG,DT_FORMATS(i));
   EXCEPTION
   WHEN OTHERS THEN
      NULL; -- Keep Trying
    END;
   END LOOP;
   --Attempt to cast one last time, but its really to designed to throw the error to the application when a string is not recognized
   RETURN  TO_TIMESTAMP(ARG,DT_FORMATS(1));
END; 

FUNCTION getNLSTSformat RETURN VARCHAR2
IS
 ts_format VARCHAR2(50);
BEGIN
  SELECT VALUE INTO ts_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_TIMESTAMP_FORMAT';
  RETURN ts_format;
END getNLSTSformat;


FUNCTION getNLSDATEformat RETURN VARCHAR2
IS
 dt_format VARCHAR2(50);
BEGIN
  SELECT VALUE INTO dt_format FROM V$NLS_PARAMETERS WHERE PARAMETER = 'NLS_DATE_FORMAT';
  RETURN DT_FORMAT;
END getNLSDATEformat;

FUNCTION PI RETURN NUMBER
IS
    pi NUMBER := 3.141592653589793116;
BEGIN
    RETURN PI;
END PI;

FUNCTION BIGINTTOHEX(P_EXPR NUMBER) RETURN VARCHAR2
IS
    l_number NUMBER;
  BEGIN
    l_number       := P_EXPR;
    -- Need to make sure that we protect against limitation on boundary condition
    IF l_number    <= -2147483647 THEN
      l_number     := -2147483647;
    ELSIF l_number >= 2147483647 THEN
      l_number     := 2147483647;
    END IF;
    RETURN RAWTOHEX(UTL_RAW.CAST_FROM_BINARY_INTEGER(l_number)) ;
END;

FUNCTION BIGINTTOHEX(P_EXPR RAW) RETURN VARCHAR2
IS
BEGIN
  RETURN RAWTOHEX(P_EXPR);
END biginttohex;

FUNCTION BIT_XOR(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
IS
BEGIN
RETURN  UTL_RAW.BIT_XOR(p_raw1,p_raw2);
END;

FUNCTION BIT_XOR(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER
IS BEGIN
RETURN BIT_OR(P_NUM1,P_NUM2) - BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_OR(P_RAW1 RAW    ,P_RAW2 RAW) RETURN RAW
IS BEGIN
RETURN  UTL_RAW.BIT_OR(p_raw1,p_raw2);
END;

FUNCTION BIT_OR(P_NUM1 NUMBER ,P_NUM2 NUMBER) RETURN NUMBER
IS BEGIN
RETURN P_NUM1 + P_NUM2 - BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_AND(P_NUM1 NUMBER   ,P_RAW1 RAW) RETURN RAW
IS BEGIN
RETURN  UTL_RAW.BIT_AND(utl_raw.cast_from_number(p_num1),p_raw1);
END;

FUNCTION BIT_AND(P_RAW1 RAW,P_NUM1 NUMBER) RETURN RAW
IS BEGIN
RETURN UTL_RAW.BIT_AND(p_raw1,utl_raw.cast_from_number(p_num1));
END;


FUNCTION BIT_AND(P_RAW1 RAW   ,P_RAW2 RAW) RETURN RAW
IS BEGIN
RETURN  UTL_RAW.BIT_AND(p_raw1,p_raw2);
END;

FUNCTION BIT_AND(P_NUM1 NUMBER,P_NUM2 NUMBER) RETURN NUMBER 
IS BEGIN
RETURN  BITAND(P_NUM1,P_NUM2);
END;

FUNCTION BIT_COMPLIMENT(P_RAW1 RAW) RETURN RAW
IS BEGIN
  RETURN UTL_RAW.BIT_COMPLEMENT(p_raw1);
END;

FUNCTION BIT_COMPLIMENT(P_NUM1 NUMBER) RETURN NUMBER
IS BEGIN
RETURN  -(P_NUM1 +1);
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TS	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN TSTZ	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN CONVERT_TO_TIMESTAMP(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_TIMESTAMP(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS
   v_format VARCHAR2(50);
BEGIN
    IF P_STYLE IS NOT NULL THEN
      V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
      RETURN TO_TIMESTAMP(P_EXPR, V_FORMAT);
    ELSE
      RETURN CONVERT_STRING_TO_TIMESTAMP(P_EXPR);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END;

FUNCTION CONVERT_TO_DATETIME(P_EXPR IN TS	  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE); 
END;

FUNCTION CONVERT_TO_DATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN CONVERT_TO_DATETIME(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

FUNCTION CONVERT_TO_DATETIME(P_EXPR IN DATE	  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS BEGIN
  RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_DATETIME(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN TS
IS
BEGIN
  RETURN CONVERT_TO_TIMESTAMP(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
   RETURN CONVERT_TO_DATE(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
END;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
END;

FUNCTION CONVERT_TO_DATE	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE));
END;



FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TS              , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
END;

FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
   RETURN CONVERT_TO_SMALLDATETIME(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN DATE	                    , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
END;

FUNCTION CONVERT_TO_SMALLDATETIME	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN DATE
IS BEGIN
  RETURN TRUNC(CONVERT_TO_DATETIME(P_EXPR,P_PRECISION,P_SCALE,P_STYLE),'MI');
END;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_NUMBER	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS BEGIN
RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
IS BEGIN
  return P_EXPR;
END;

FUNCTION CONVERT_TO_FLOAT	  (P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN FLOAT
IS BEGIN
  return p_expr;
END;

---
FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS BEGIN
  RETURN P_EXPR;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS
   v_format VARCHAR2(50);
   v_result VARCHAR2(100);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  IF P_PRECISION <> 0 THEN
    v_result := SUBSTR(v_result,1,p_precision);
  END IF;
  RETURN v_result;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS
   v_format VARCHAR2(50);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    RETURN TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    RETURN TO_CHAR(P_EXPR);
  END IF;
END;

FUNCTION CONVERT_TO_VARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN VARCHAR2
IS BEGIN
   RETURN CONVERT_TO_VARCHAR2(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

FUNCTION CONVERT_TO_NUMBER(P_BLOB_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NUMBER
IS
  v_expr RAW(32767);
BEGIN
    v_expr := DBMS_LOB.SUBSTR(P_BLOB_EXPR);
    -- v_expr := REGEXP_REPLACE(v_expr, '0x', '', 1, 1, 'i');
    RETURN UTL_RAW.CAST_TO_BINARY_INTEGER (v_expr, 3);  -- where 3 is machine_endian
END;

FUNCTION CONVERT_TO_BLOB(P_EXPR IN NUMBER, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
IS
BEGIN
   RETURN UTL_RAW.CAST_FROM_BINARY_INTEGER(P_EXPR, 3); -- where 3 is machine_endian
END;

FUNCTION CONVERT_TO_RAW(P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN RAW
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_RAW ( P_EXPR ) ;
END;

FUNCTION CONVERT_TO_VARCHAR2(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN VARCHAR2
IS
  v_expr RAW(32767);
BEGIN
   v_expr := DBMS_LOB.SUBSTR(P_EXPR);
   RETURN UTL_RAW.CAST_TO_VARCHAR2(v_expr);
END;

FUNCTION CONVERT_TO_BLOB(P_EXPR IN VARCHAR2, P_PRECISION IN NUMBER DEFAULT 0, P_SCALE IN NUMBER DEFAULT 0, P_STYLE IN NUMBER DEFAULT 0) RETURN BLOB
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_RAW(P_EXPR);
END;

FUNCTION SUBSTR_(P_EXPR IN VARCHAR2,P_PRECISION IN NUMBER DEFAULT NULL) RETURN CHAR
AS
BEGIN
  IF P_PRECISION IS  NULL THEN
    RETURN SUBSTR(P_EXPR,1,DEFAULT_CHAR_SIZE);
  ELSE
    RETURN SUBSTR(P_EXPR,1,P_PRECISION);
  END IF;
END;
--- MASTER CONVERT_TO_CHAR for DATETIME values
FUNCTION CONVERT_TO_CHAR_(P_EXPR IN TS	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
V_FORMAT VARCHAR2(100);
V_RESULT VARCHAR2(4000);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  RETURN SUBSTR_(v_result,P_PRECISION);
END;
---
FUNCTION CONVERT_TO_CHAR	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT NULL  , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS BEGIN
  RETURN  SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
   v_format VARCHAR2(50);
   v_result CHAR(4000);
BEGIN
   RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS
   v_format VARCHAR2(50);
BEGIN
   RETURN CONVERT_TO_CHAR_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CHAR	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CHAR
IS BEGIN
   RETURN CONVERT_TO_CHAR(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE))); 
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
   RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
END;   

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS
BEGIN
  RETURN UTL_RAW.CAST_TO_NVARCHAR2(UTL_RAW.CAST_TO_RAW(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE)));
END;

FUNCTION CONVERT_TO_NVARCHAR2	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN NVARCHAR2
IS BEGIN
   RETURN CONVERT_TO_NVARCHAR2(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

--- MASTER CONVERT_TO_CLOB for DATETIME values
FUNCTION CONVERT_TO_CLOB_(P_EXPR IN TS	, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
V_FORMAT VARCHAR2(100);
V_RESULT VARCHAR2(4000);
BEGIN
  IF P_STYLE IS NOT NULL THEN
    V_FORMAT := GET_FORMAT_FROM_STYLE(P_STYLE);
    v_result := TO_CHAR(P_EXPR,V_FORMAT);  
  ELSE
    v_result := TO_CHAR(P_EXPR);
  END IF;
  
  RETURN SUBSTR_(v_result,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TSTZ	, P_PRECISION IN NUMBER DEFAULT NULL, P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
   RETURN CONVERT_TO_CLOB(CAST(P_EXPR AS TS),P_PRECISION,P_SCALE,P_STYLE); --REMOVE TZ
END;

---
FUNCTION CONVERT_TO_CLOB	(P_EXPR IN CLOB	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN VARCHAR2	                , P_PRECISION IN NUMBER DEFAULT 4000, P_SCALE IN NUMBER DEFAULT NULL, P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
     RETURN SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN NUMBER  	                , P_PRECISION IN NUMBER DEFAULT 4000 , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS BEGIN
  RETURN  SUBSTR_(P_EXPR,P_PRECISION);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN DATE		                  , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
   v_format VARCHAR2(50);
   v_result CHAR(4000);
BEGIN
   RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;

FUNCTION CONVERT_TO_CLOB	(P_EXPR IN TS		            , P_PRECISION IN NUMBER DEFAULT NULL   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT NULL) RETURN CLOB
IS
   v_format VARCHAR2(50);
BEGIN
   RETURN CONVERT_TO_CLOB_(P_EXPR,P_PRECISION,P_SCALE,P_STYLE);
END;


-- commented out for now as it returns null
--FUNCTION CONVERT_TO_CHAR(P_EXPR IN BLOB, P_PRECISION IN NUMBER DEFAULT 0   , P_SCALE IN NUMBER DEFAULT 0   , P_STYLE IN NUMBER DEFAULT 0) RETURN CHAR
--IS
--BEGIN
--     RETURN SUBSTR_(CONVERT_TO_VARCHAR2(P_EXPR, P_PRECISION, P_SCALE, P_STYLE), P_PRECISION);
--END;

FUNCTION datename_(p_part_expr IN VARCHAR2, p_date_expr IN TS)
RETURN VARCHAR2
IS
  v_part VARCHAR2(15);
  v_timestamp TS := p_date_expr;
  v_wkday VARCHAR2(10);
  v_year VARCHAR2(4);
  v_temp VARCHAR2(30);
BEGIN
      v_part := UPPER(p_part_expr);
      IF v_part IN ('YEAR', 'YY', 'YYYY') THEN RETURN TO_CHAR(v_timestamp, 'YYYY');
      ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN RETURN TO_CHAR(v_timestamp, 'Q');
      ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_CHAR(v_timestamp, 'Month');
      ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
      ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_CHAR(v_timestamp, 'DD');
      ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_CHAR(v_timestamp, 'Day');
      ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
         -- commented out this code for now needs to be reviewed if the
         -- result is not consistent with sybase function call datename(wk,getdate())
         -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
         /*
         v_year := TO_CHAR(v_timestamp, 'YYYY');
         v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, 'MM-DD-YYYY'), 'DAY');
         IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
            RETURN TO_CHAR(v_timestamp, 'WW');
         ELSE
            RETURN TO_CHAR(v_timestamp, 'WW') + 1;
         END IF;
         */
         RETURN TO_CHAR(v_timestamp, 'WW');
      ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_CHAR(v_timestamp, 'fmHH24');
      ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_CHAR(v_timestamp, 'fmMI');
      ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_CHAR(v_timestamp, 'fmSS');
      ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF3');
          IF v_temp = '000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;   
      ElSIF v_part IN ('MICROSECOND', 'MCS', 'FF6') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF6');
          IF v_temp = '000000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;
      ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN 
          v_temp := TO_CHAR(v_timestamp, 'FF9');
          IF v_temp = '000000000' THEN
             RETURN '0';
          ELSE   
             RETURN v_temp;
          END IF;
      ElSIF v_part IN ('TZOFFSET', 'TZ') THEN RETURN TO_CHAR(v_timestamp, 'TZH') || ':' || TO_CHAR(v_timestamp, 'TZM');
      ELSE
        RETURN NULL;
      END IF;

EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
END datename_;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2) 
RETURN VARCHAR2
IS
    v_part VARCHAR2(15);
    v_date DATE;
    v_ts TS;
    v_wkday VARCHAR2(10);
    v_year VARCHAR2(4);
BEGIN
      v_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_date_str));   
      RETURN datename_(p_part_expr, v_TS);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);  
END datename;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN DATE) 
RETURN VARCHAR2
IS
BEGIN
    RETURN datename_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END datename;

FUNCTION datename(p_part_expr IN VARCHAR2, p_date_expr IN TS) 
RETURN VARCHAR2
IS
BEGIN
   RETURN datename_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END datename;

FUNCTION DATENAME(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ)  RETURN VARCHAR2
IS BEGIN
   RETURN DATENAME(P_PART_EXPR , CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
END;


FUNCTION datepart_(p_part_expr IN VARCHAR2, p_date_expr IN TS)
RETURN NUMBER
IS
  v_part VARCHAR2(15) := p_part_expr;
  v_timestamp TS := p_date_expr;
  v_wkday VARCHAR2(10);
  v_year VARCHAR2(4);
BEGIN
      v_part := UPPER(p_part_expr);
      IF v_part IN ('YEAR', 'YY', 'YYYY') THEN  RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'YYYY'));
      ELSIF v_part IN ('QUARTER', 'QQ', 'Q')  THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'Q'));
      ELSIF v_part IN ('MONTH', 'MM', 'M') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MM'));
      ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DDD'));
      ELSIF v_part IN ('DAY', 'DD', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'DD'));
      ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D'));
      -- Oracle returns 1 short when compared to Sybase so adding 1 to the result.
      ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN  
         v_year := TO_CHAR(v_timestamp, 'YYYY');
         FOR i in DT_FORMATS.FIRST .. DT_FORMATS.LAST
         LOOP
            BEGIN
              v_wkday := TO_CHAR(TO_DATE('01-01-'|| v_year, DT_FORMATS(i)), 'DAY');
              EXIT;
            EXCEPTION
             WHEN OTHERS THEN
                NULL; 
            END;
         END LOOP;
         IF v_wkday = TO_CHAR(v_timestamp, 'DAY') THEN
            RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW'));
         ELSE
            RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'WW')) + 1;
         END IF; 
      ElSIF v_part IN ('HOUR', 'HH') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'HH24'));
      ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'MI'));
      ElSIF v_part IN ('SECOND', 'SS', 'S') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'SS'));
      ElSIF v_part IN ('MILLISECOND', 'MS', 'FF3') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF3'));
      ElSIF v_part IN ('MICROSECOND', 'MCS', 'US', 'FF6') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF6'));
      ElSIF v_part IN ('NANOSECOND', 'NS', 'FF9') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'FF9'));
      ElSIF v_part IN ('CALYEAROFWEEK', 'CYR', 'IYYY') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IYYY')); 
      ElSIF v_part IN ('CALWEEKOFYEAR', 'CWK', 'IW') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'IW'));
      -- Oracle returns 1 more when compared to Sybase so subtract 1 to the result.
      ElSIF v_part IN ('CALDAYOFWEEK', 'CDW', 'D') THEN RETURN TO_NUMBER(TO_CHAR(v_timestamp, 'D')) - 1;
      ELSE
        RETURN NULL;
      END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END datepart_;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_str IN VARCHAR2)
RETURN NUMBER
IS
   v_ts TS;
BEGIN  
      v_ts := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
      RETURN datepart_(p_part_expr, v_ts);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
END datepart;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN TS)
RETURN NUMBER
IS
BEGIN
    RETURN datepart_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datepart;

FUNCTION DATEPART(P_PART_EXPR IN VARCHAR2, P_DATE_EXPR IN TSTZ) RETURN NUMBER
IS BEGIN
   RETURN DATEPART(P_PART_EXPR , CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
END;

FUNCTION datepart(p_part_expr IN VARCHAR2, p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN datepart_(p_part_expr, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datepart;


FUNCTION dateadd_(p_interval IN VARCHAR2,  p_interval_val IN NUMBER, p_date_exp IN TS)
RETURN TS
IS
  v_ucase_interval VARCHAR2(10);
  v_date TS;
  v_datestr VARCHAR2(30);
  v_result TS;
BEGIN
    v_date := p_date_exp;
    v_ucase_interval := UPPER(p_interval);    
    IF v_ucase_interval IN ('YEAR', 'YY', 'YYYY') 
    THEN
      RETURN ADD_MONTHS(v_date, p_interval_val * 12);
    ELSIF v_ucase_interval IN ('QUARTER', 'QQ', 'Q') 
    THEN
      IF LAST_DAY(v_date) = v_date THEN
         v_datestr := EXTRACT(MONTH FROM v_date) + (p_interval_val * 3);
         v_datestr := v_datestr || '-' || EXTRACT(DAY FROM v_date) || '-' || EXTRACT(YEAR FROM v_date);
         v_datestr := v_datestr || ' ' || TO_CHAR(v_date, 'HH12') || ':' || TO_CHAR(v_date, 'MI') || ':' || TO_CHAR(v_date, 'SS');
         v_datestr := v_datestr || '.' || TO_CHAR(v_date, 'FF3 AM') ;
         v_result := TO_TIMESTAMP(v_datestr, 'MM-DD-YYYY HH12:MI:SS.FF3 AM');
         RETURN v_result;
      ELSE
         RETURN ADD_MONTHS(v_date, p_interval_val * 3);
      END IF;   
    ELSIF v_ucase_interval IN ('MONTH', 'MM', 'M') 
    THEN
      BEGIN
         v_result := v_date + NUMTOYMINTERVAL(p_interval_val, 'MONTH') + NUMTODSINTERVAL(0, 'HOUR');
      EXCEPTION WHEN OTHERS THEN
       --problem due to resulting date not being able to handle a particular day like (Ex: Feb 31)
       v_result := ADD_MONTHS(v_date, p_interval_val) ; -- this will use the last valid day (Ex: Feb 28)
      END;
      RETURN v_result;
    ElSIF v_ucase_interval IN ('DAYOFYEAR', 'DY', 'Y', 'DAY', 'DD', 'D', 'WEEKDAY', 'DW', 'W') 
    THEN
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'DAY');
    ElSIF v_ucase_interval IN ('WEEK', 'WK', 'WW') 
    THEN
      RETURN v_date + (p_interval_val * 7);
    ElSIF v_ucase_interval IN ('HOUR', 'HH') 
    THEN
      -- RETURN v_date + (p_interval_val / 24);
       RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'HOUR');
    ElSIF v_ucase_interval IN ('MINUTE', 'MI', 'N') 
    THEN
      -- RETURN v_date + NUMTODSINTERVAL((p_interval_val / 24 / 60), 'MINUTE');
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'MINUTE');
    ElSIF v_ucase_interval IN ('SECOND', 'SS', 'S') 
    THEN
      -- RETURN v_date + (p_interval_val / 24 / 60 / 60);
      RETURN v_date + NUMTODSINTERVAL(p_interval_val, 'SECOND');
    ElSIF v_ucase_interval IN ('MILLISECOND', 'MS') 
    THEN
      -- result accurate to one three-hundredth of a second 
      RETURN v_date + NUMTODSINTERVAL(3.33 * ROUND(p_interval_val/3.33), 'SECOND')/1000;
    ELSE
      RETURN NULL;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK); 
END dateadd_;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_str IN VARCHAR2)
RETURN TS
IS
    v_ts TS;
BEGIN
    v_ts := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
    RETURN dateadd_(p_interval, p_interval_val, v_ts);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN DATE)
RETURN DATE
IS
BEGIN
    RETURN CAST(dateadd_(p_interval, p_interval_val, p_date_expr) AS DATE);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION dateadd(p_interval IN VARCHAR2, p_interval_val IN NUMBER, p_date_expr IN TS)
RETURN TS
IS  
BEGIN
    RETURN dateadd_(p_interval, p_interval_val, p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END dateadd;

FUNCTION DATEADD(P_INTERVAL IN VARCHAR2, P_INTERVAL_VAL IN NUMBER, P_DATE_EXPR IN TSTZ) RETURN TS
IS BEGIN
   RETURN DATEADD(P_INTERVAL ,P_INTERVAL_VAL, CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
END;

FUNCTION degrees(p_angle_radians IN NUMBER) 
RETURN NUMBER
IS
BEGIN
    IF p_angle_radians IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN ROUND(p_angle_radians / pi() * 180);
EXCEPTION 
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END degrees;

--SQLSERVER
FUNCTION year_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    RETURN TO_NUMBER(TO_CHAR(v_date, 'YYYY'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;

FUNCTION year_(p_date_expr IN DATE) 
RETURN NUMBER
IS
BEGIN
   RETURN EXTRACT(YEAR FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;

FUNCTION year_(p_date_expr IN TS)
RETURN NUMBER
IS
BEGIN
   RETURN EXTRACT(YEAR FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END year_;

FUNCTION YEAR_(P_DATE_EXPR   IN TSTZ) RETURN NUMBER
IS BEGIN
   RETURN YEAR_(CAST(P_DATE_EXPR AS TS)); --REMOVE TZ
END;

FUNCTION difference(p_expr1 IN VARCHAR2, p_expr2 IN VARCHAR2)
RETURN NUMBER
IS
    sound_ex_val_1 CHAR(4);
    sound_ex_val_2 CHAR(4);
    similarity NUMBER := 0;
    idx NUMBER := 1; 
BEGIN
    IF p_expr1 IS NULL OR p_expr2 IS NULL THEN
       RETURN NULL;
    END IF; 
    sound_ex_val_1 := SOUNDEX(p_expr1);
    sound_ex_val_2 := SOUNDEX(p_expr2); 
    LOOP
       IF SUBSTR(sound_ex_val_1, idx, 1) = SUBSTR(sound_ex_val_2, idx, 1) THEN
          similarity := similarity + 1;
       END IF;
       
       idx := idx + 1;   
       EXIT WHEN idx > 4;
    END LOOP;
    RETURN similarity;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END difference;

FUNCTION datediff_sqlserver(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
RETURN NUMBER
IS
    v_ret_value NUMBER := NULL;
    v_part VARCHAR2(15);
    v_start_ts  TS;
    v_end_ts  TS;
    v_start_date  DATE;
    v_end_date  DATE;
BEGIN
    v_part := p_datepart;
    v_start_ts := p_start_date_expr;
    v_end_ts := p_end_date_expr;
    v_start_date := TO_DATE(EXTRACT(YEAR FROM v_start_ts) || '-' || EXTRACT(MONTH FROM v_start_ts) || '-' || EXTRACT(DAY FROM v_start_ts), 'YYYY-MM-DD');
    v_end_date := TO_DATE(EXTRACT(YEAR FROM v_end_ts) || '-' || EXTRACT(MONTH FROM v_end_ts) || '-' || EXTRACT(DAY FROM v_end_ts), 'YYYY-MM-DD');
    v_part := UPPER(p_datepart);
    
    IF v_part IN ('YEAR', 'YY', 'YYYY') THEN
      v_ret_value :=EXTRACT(YEAR FROM v_end_ts) - EXTRACT(YEAR FROM v_start_ts) ;
    ELSIF v_part IN ('QUARTER', 'QQ', 'Q') THEN
       v_ret_value := ROUND(MONTHS_BETWEEN(v_end_ts, v_start_ts) / 3);
    ELSIF v_part IN ('MONTH', 'MM', 'M') THEN
       v_ret_value := ROUND(MONTHS_BETWEEN(TRUNC(v_end_ts, 'MM'), TRUNC(v_start_ts, 'MM')));
     ElSIF v_part IN ('DAYOFYEAR', 'DY', 'Y') THEN
       v_ret_value := ROUND(CAST(v_end_ts AS DATE) - CAST(v_start_ts AS DATE));
    ElSIF v_part IN ('DAY', 'DD', 'D') THEN
       v_ret_value := ROUND(v_end_date - v_start_date);
    ElSIF v_part IN ('WEEK', 'WK', 'WW') THEN
       v_ret_value := ROUND((CAST(v_end_ts AS DATE) - CAST(v_start_ts AS DATE)) / 7);
    ELSIF v_part IN ('WEEKDAY', 'DW', 'W') THEN
       -- v_ret_value := TO_CHAR(v_end_ts, 'D') - TO_CHAR(v_start_ts, 'D');
       -- In Sybase the result is similar to using date part 'Week 'or 'wk' in datediff function
       IF EXTRACT(YEAR FROM v_end_ts) = EXTRACT(YEAR FROM v_start_ts) THEN
          v_ret_value := EXTRACT(DAY FROM v_end_ts) - EXTRACT(DAY FROM v_start_ts);
       ELSE
          v_ret_value := ROUND((TRUNC(v_end_ts, 'DD') - TRUNC(v_start_ts, 'DD')) / 7);
       END IF;
    ElSIF v_part IN ('HOUR', 'HH') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24;
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts))));
    ElSIF v_part IN ('MINUTE', 'MI', 'N') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts))));
    ElSIF v_part IN ('SECOND', 'SS', 'S') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts))));
    ElSIF v_part IN ('MILLISECOND', 'MS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000));
    ElSIF v_part IN ('MICROSECOND', 'MCS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000000));
    ElSIF v_part IN ('NANOSECOND', 'NS') THEN
       v_ret_value := ROUND(v_end_date - v_start_date) * 24 * 60 * 60 * 1000000000;
       v_ret_value := v_ret_value + ((EXTRACT(HOUR FROM v_end_ts) - EXTRACT(HOUR FROM v_start_ts)) * 60 * 60 * 1000000000);
       v_ret_value := v_ret_value + ((EXTRACT(MINUTE FROM v_end_ts) - EXTRACT(MINUTE FROM v_start_ts)) * 60 * 1000000000);
       v_ret_value := ROUND(v_ret_value + ((EXTRACT(SECOND FROM v_end_ts) - EXTRACT(SECOND FROM v_start_ts)) * 1000000000));
    END IF;
    RETURN v_ret_value;
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff_sqlserver;

--http://st-doc.us.oracle.com/database/121/SQLRF/functions066.htm#SQLRF00639
--TIMESTAMP-TIMESTAMP = INTERVAL DAY TO SECOND
FUNCTION datediff_sybase(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
RETURN NUMBER
IS
    v_ret_value NUMBER := NULL;
    v_diff INTERVAL DAY(9) TO SECOND(9);
    v_years NUMBER;
    v_weeks NUMBER;
    v_days NUMBER;
    v_hours NUMBER;
    v_minutes NUMBER;
    v_seconds NUMBER;
    v_milliseconds NUMBER;
    v_microseconds NUMBER;
BEGIN
    v_diff := p_end_date_expr -  p_start_date_expr;
    --TIMESTAMP - TIMESTAMP  = INTERVAL DAY TO SECOND
    v_days := EXTRACT(DAY FROM v_diff);
    v_hours := EXTRACT(HOUR FROM v_diff);
    v_minutes :=EXTRACT(MINUTE FROM v_diff);
    v_seconds :=EXTRACT(SECOND FROM v_diff);
    --MILLISECONDS: In Sybase only 1 second precision is taken into account
    v_milliseconds := v_seconds - TRUNC(v_seconds);--full milliseconds (0.123456)
    v_milliseconds := ROUND(v_milliseconds*10)*100;--only 1 precision of milliseconds (100);
    v_microseconds := v_seconds - TRUNC(v_seconds);--full microseconds(0.123456)
    v_microseconds := TRUNC(v_microseconds * 1000000);
    
    IF p_datepart IN ('WEEK', 'WK', 'WW') THEN
           v_ret_value :=  (NEXT_DAY(TRUNC(p_end_date_expr),'Sunday') -  NEXT_DAY(TRUNC(p_start_date_expr),'Sunday'))/7 ;
    ELSIF p_datepart IN ('DAY', 'DD', 'D','DAYOFYEAR', 'DY', 'Y') THEN
        --CANT USER THE INTERVAL DIFF(v_difF), AS EVEN 2 SECONDS COULD SEPERATE A DAY (1 second before midnight, 1 second after midnight
        --INSTEAD FIRST REMOVE HOURS/MINS FROM INITIAL VALUES THEN FIND THE INTERVAL
         v_ret_value :=  TRUNC(p_end_date_expr) -  TRUNC(p_start_date_expr);
    ElSIF p_datepart IN ('HOUR', 'HH') THEN
          v_ret_value := (v_days*24)+v_hours;
    ElSIF p_datepart IN ('MINUTE', 'MI', 'N') THEN
          v_ret_value :=(v_days*24*60)+(v_hours*60)+v_minutes;
    ElSIF p_datepart IN ('SECOND', 'SS', 'S') THEN
        --SECONDS CAN HAVE MILLISECONDS AS WELL, SO NEED TO TRUNCATE THESE IN SYBASE
          v_ret_value := (v_days*24*60*60)+(v_hours*60*60)+(v_minutes*60)+TRUNC(v_seconds);
    ElSIF p_datepart IN ('MILLISECOND', 'MS') THEN
          v_ret_value := (v_days*24*60*60*1000)+(v_hours*60*60*1000)+(v_minutes*60*1000)+(TRUNC(v_seconds)*1000)+v_milliseconds;
    ElSIF p_datepart IN ('MICROSECOND', 'MCS') THEN 
          v_ret_value := (v_days*24*60*60*1000000)+(v_hours*60*60*1000000)+(v_minutes*60*1000000)+(TRUNC(v_seconds)*1000000)+v_microseconds;
    ElSIF p_datepart IN ('NANOSECOND', 'NS') THEN
        --NANOSECONDS: In Sybase only 1 second precision is taken into account
          v_ret_value := (v_days*24*60*60*1000000)+(v_hours*60*60*1000000)+(v_minutes*60*1000000)+(TRUNC(v_seconds)*1000000000)+(v_microseconds*100);
    ELSIF p_datepart IN ('QUARTER', 'QQ', 'Q') THEN
       v_ret_value :=   (TO_CHAR(p_end_date_expr,'YYYY')*4 +
                         TO_CHAR(p_end_date_expr,'Q'))
                        -
                        (TO_CHAR(p_start_date_expr,'YYYY')*4  +
                         TO_CHAR(p_start_date_expr,'Q'));
    ELSIF p_datepart IN ('WEEKDAY', 'DW', 'W') THEN --WEEKDAY IN SYBASE RETURNS THE NUMBER OF WEEKS!
      v_ret_value :=  TRUNC((TRUNC(p_end_date_expr) -  TRUNC(p_start_date_expr))/7);
    ELSE   
          v_ret_value := datediff_sqlserver(p_datepart,p_start_date_expr,p_end_date_expr);
    END IF;
    RETURN v_ret_value;
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff_sybase;

FUNCTION datediff_(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
RETURN NUMBER
AS BEGIN
 IF DATABASE_TYPE = SYBASE THEN
    RETURN datediff_sybase(UPPER(p_datepart),p_start_date_expr,p_end_date_expr);
 ELSE
    RETURN datediff_sqlserver(p_datepart,p_start_date_expr,p_end_date_expr);
 END IF;
END datediff_;

FUNCTION NUMBERTODATE (P_NUM NUMBER) RETURN DATE
IS BEGIN
  RETURN ZERODATETIME()+P_NUM;
END;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_str IN VARCHAR2, p_end_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_start_ts  TS;
    v_end_ts  TS;
BEGIN
  v_start_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str));
  v_end_ts := CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str));
   RETURN datediff_(p_datepart, v_start_ts, v_end_ts);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN DATE, p_end_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
      RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
END;

FUNCTION datediff(p_datepart IN VARCHAR2, p_start_date_expr IN TS, p_end_date_expr IN TS)
RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END datediff;


FUNCTION datediff(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str)), p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,P_START_DATE_STR,NUMBERTODATE(P_END_DATE_EXPR));
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TS) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_start_date_str)), p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_STR IN VARCHAR2, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
IS BEGIN
   RETURN DATEDIFF(P_DATEPART,P_START_DATE_STR , CAST(P_END_DATE_EXPR AS TS)); --REMOVE TZ
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str)));
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TS) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;
 
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN DATE, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
IS
BEGIN
     RETURN datediff(p_datepart, p_start_date_expr, CAST(p_end_date_expr AS TS));
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
IS BEGIN
RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),NUMBERTODATE(P_END_DATE_EXPR));
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_STR);
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TS) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN NUMBER, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
IS BEGIN
  RETURN DATEDIFF(P_DATEPART,NUMBERTODATE(P_START_DATE_EXPR),P_END_DATE_EXPR);
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr, p_end_date_expr);
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
IS BEGIN
 RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
END;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS
BEGIN
     RETURN datediff_(p_datepart, p_start_date_expr,  CONVERT_STRING_TO_TIMESTAMP(TRIM(p_end_date_str)));
EXCEPTION
     WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TS, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
IS BEGIN
     RETURN datediff(p_datepart, p_start_date_expr,  CAST(P_END_DATE_EXPR AS TS));--REMOVE TZ
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TSTZ) RETURN NUMBER
IS BEGIN
RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN TS) RETURN NUMBER
IS BEGIN
RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN DATE) RETURN NUMBER
IS BEGIN
RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_EXPR);--REMOVE TZ
END DATEDIFF;

FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_EXPR IN NUMBER) RETURN NUMBER
IS BEGIN
 RETURN DATEDIFF(P_DATEPART,P_START_DATE_EXPR,NUMBERTODATE(P_END_DATE_EXPR));
END;
FUNCTION DATEDIFF(P_DATEPART IN VARCHAR2, P_START_DATE_EXPR IN TSTZ, P_END_DATE_STR IN VARCHAR2) RETURN NUMBER
IS BEGIN
RETURN DATEDIFF(P_DATEPART,CAST(P_START_DATE_EXPR AS TS),P_END_DATE_STR);--REMOVE TZ
END DATEDIFF;

FUNCTION month_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
    v_dateformat VARCHAR2(50);
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN TO_NUMBER(TO_CHAR(v_date, 'MM'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION month_(p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(MONTH FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION month_(p_date_expr IN TS)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(MONTH FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END MONTH_;

FUNCTION MONTH_(P_DATE_EXPR  IN TSTZ) RETURN NUMBER
IS
BEGIN
    RETURN MONTH_(CAST(p_date_expr AS TS));
END MONTH_;

-- PUBLIC NOT REFACTORED YET
FUNCTION rand(p_seed NUMBER DEFAULT NULL)
RETURN NUMBER
IS
    v_rand_num NUMBER;
BEGIN
      IF p_seed IS NOT NULL THEN
         DBMS_RANDOM.SEED(p_seed);
      END IF;
      
      v_rand_num := DBMS_RANDOM.VALUE();
      
      RETURN v_rand_num;
EXCEPTION
     WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END rand;

PROCEDURE resetTrancount
IS
BEGIN	
   trancount := 0;
END resetTrancount;

FUNCTION isnumeric(p_expr IN VARCHAR2)
RETURN NUMBER
IS
    numeric_val NUMBER;
    temp_str VARCHAR2(50);
BEGIN
    temp_str := p_expr;
    IF SUBSTR(temp_str, 1, 1) = '$' THEN
       temp_str := SUBSTR(temp_str, 2);
    END IF;
    
    numeric_val := TO_NUMBER(temp_str);
    RETURN 1;
EXCEPTION
    WHEN OTHERS THEN
       RETURN 0;
END isnumeric;

FUNCTION stats_date(p_table IN VARCHAR2, p_index IN VARCHAR2)
RETURN DATE
IS
    v_last_analyzed DATE;
BEGIN
    SELECT last_analyzed INTO v_last_analyzed
      FROM USER_IND_STATISTICS
     WHERE table_name LIKE UPPER(p_table)
       AND index_name LIKE UPPER(p_index);
  
    RETURN v_last_analyzed;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END stats_date;

FUNCTION oct(p_num VARCHAR2)
RETURN VARCHAR2
IS
BEGIN
    RETURN to_base(p_num, 8);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END oct;

FUNCTION quotename(p_str IN VARCHAR2, p_delimiters IN VARCHAR2 DEFAULT '[]')
RETURN VARCHAR2
IS
    v_ret_val VARCHAR2(150) := NULL;
BEGIN
    IF p_delimiters = '[]' THEN
       v_ret_val := '[' || REPLACE(p_str, ']', ']]') || ']';
    ELSIF p_delimiters = '"' THEN
       v_ret_val := '"' || p_str || '"';
    ELSIF p_delimiters = '''' THEN
       v_ret_val := '''' || p_str || '''';
      END IF;
     
      RETURN v_ret_val;
EXCEPTION
      WHEN OTHERS THEN
         raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END quotename;

FUNCTION parsename(p_object_name IN VARCHAR2, p_object_piece IN NUMBER)
RETURN VARCHAR2
IS
    ret_val VARCHAR2(150) := NULL;
    pos NUMBER;
    v_next_pos NUMBER;
BEGIN
    IF p_object_name IS NULL THEN 
       RETURN NULL;
    END IF;
    
    -- for 10g
    IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
      IF p_object_piece = 1 THEN -- object name
         ret_val := REGEXP_SUBSTR(p_object_name, '(^[^\.]+$)|(\.[^\.]+$)');
         ret_val := REPLACE(ret_val, '.', '');
      ELSIF p_object_piece = 2 THEN -- schema name
         ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]+$)');
         ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]+$)', '');
      ELSIF p_object_piece = 3 THEN -- database name
         ret_val := REGEXP_SUBSTR(p_object_name, '([^\.]+)\.([^\.]*)\.([^\.]+$)');
         ret_val := REGEXP_REPLACE(ret_val, '\.([^\.]*)\.([^\.]+$)', '');
      ELSIF p_object_piece = 4 THEN -- server name
         ret_val := REGEXP_SUBSTR(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)');
         IF ret_val IS NOT NULL THEN
           ret_val := REGEXP_REPLACE(p_object_name, '^([^\.]+)\.([^\.]*)\.([^\.]*)\.([^\.]+$)', '\1');
         END IF;
      END IF;
    ELSE
      ret_val := p_object_name;
      v_next_pos := LENGTH(p_object_name);
      FOR i IN 1 .. p_object_piece LOOP
        pos := INSTR(p_object_name, '.', -1, i);
        IF pos > 0 THEN
          ret_val := SUBSTR(p_object_name, pos + 1, v_next_pos - pos);
        END IF;
        v_next_pos := pos;
      END LOOP;
      
      IF LENGTH(ret_val) = 0 THEN
        RETURN NULL;
      END IF;
    END IF;
    
    RETURN ret_val;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END PARSENAME;

FUNCTION fetch_status(p_cursorfound IN BOOLEAN)
RETURN NUMBER
IS
     v_fetch_status NUMBER := 0;
BEGIN
   CASE
     WHEN p_cursorfound THEN
        v_fetch_status := 0; --fetch successful
     ELSE
        v_fetch_status := -1; --fetch unsuccessful
     END CASE;
     RETURN v_fetch_status;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END fetch_status;

FUNCTION sqlstatus(p_cursorfound IN BOOLEAN,p_cursoropen IN BOOLEAN)
RETURN NUMBER
IS
     v_sqlerror NUMBER := 0;
BEGIN
   CASE
     WHEN NOT p_cursoropen THEN
        v_sqlerror := 1; -- fetch statement resulted in an error
     WHEN p_cursorfound THEN
        v_sqlerror := 0; --successful completion
     ELSE 
 		v_sqlerror :=2;  --no more data in result set
     END CASE;
     RETURN v_sqlerror;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END sqlstatus;

FUNCTION ident_seed(p_sequence IN VARCHAR2)
RETURN NUMBER
IS
    v_seed NUMBER;
BEGIN
      SELECT min_value INTO v_seed
         FROM USER_SEQUENCES
         WHERE sequence_name LIKE UPPER(p_sequence);
  
      RETURN v_seed;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END IDENT_SEED;

FUNCTION to_base(p_dec NUMBER, p_base NUMBER) 
RETURN VARCHAR2
IS
    v_str VARCHAR2(255);
    v_num NUMBER;
    v_hex VARCHAR2(16) DEFAULT '0123456789ABCDEF';
BEGIN
    v_num := p_dec;
    
    IF p_dec IS NULL OR p_base IS NULL THEN
      RETURN NULL;
    END IF;

    IF TRUNC(p_dec) <> p_dec OR p_dec < 0 THEN
        RAISE PROGRAM_ERROR;
    END IF;
    
    LOOP
      v_str := SUBSTR(v_hex, MOD(v_num, p_base) + 1, 1) || v_str;
      v_num := TRUNC(v_num / p_base);
      
      EXIT WHEN v_num = 0;
    END LOOP;
    
    RETURN v_str;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END TO_BASE;

FUNCTION TO_SECOND(P_TIME VARCHAR2) 
RETURN NUMBER
IS
  v_hours NUMBER;
  v_minutes NUMBER;
  v_seconds NUMBER;
  v_tot_seconds NUMBER;
BEGIN
  v_hours := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\2');
  v_minutes := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\3');
  v_seconds := REGEXP_REPLACE(P_TIME, '((\d{1,2})\:(\d{2})\:(\d{2}))', '\4');
  v_tot_seconds := v_hours * 60 * 60 + v_minutes * 60 + v_seconds;
  RETURN v_tot_seconds;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END TO_SECOND;

PROCEDURE decrementTrancount
IS
BEGIN	
	IF trancount > 0 THEN
      	trancount := trancount - 1;
   	END IF;
END decrementTrancount;

FUNCTION hex(p_num VARCHAR2)
RETURN VARCHAR2
IS
BEGIN
    RETURN to_base(p_num, 16);
  EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END hex;

FUNCTION isdate(p_expr IN VARCHAR2)
RETURN NUMBER
IS
     v_is_valid_date BINARY_INTEGER := 0;
BEGIN
    IF CONVERT_STRING_TO_TIMESTAMP(p_expr) IS NOT NULL THEN
       RETURN 1;
    ELSE 
       SELECT NVL2(TO_DATE(p_expr), 1, 0) INTO v_is_valid_date FROM DUAL;
       RETURN v_is_valid_date;
    END IF;    
EXCEPTION 
    WHEN OTHERS THEN
       RETURN 0;
END isdate;

FUNCTION radians(p_degree IN NUMBER)
RETURN NUMBER
IS
    v_rad NUMBER;
BEGIN
    v_rad := p_degree / 180 * pi();
    
    IF INSTR(TO_CHAR(p_degree),'.') = 0 THEN
        v_rad := FLOOR(v_rad);
    ELSE 
        v_rad := round(p_degree / 180 * pi(),18); 
    END IF;
      
    RETURN v_Rad ;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END radians;

FUNCTION GETIDENTITY RETURN NUMBER
IS
BEGIN
 RETURN IDENTITY_VALUE;
END;

FUNCTION ident_incr(p_sequence IN VARCHAR2)
RETURN NUMBER
IS
    v_incr_by NUMBER;
BEGIN
    SELECT increment_by INTO v_incr_by
       FROM USER_SEQUENCES
       WHERE sequence_name LIKE UPPER(p_sequence);

    RETURN v_incr_by;
EXCEPTION
    WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END ident_incr;

FUNCTION day_(p_date_str IN VARCHAR2)
RETURN NUMBER
IS
    v_date DATE;
BEGIN
    v_date := CONVERT_STRING_TO_TIMESTAMP(p_date_str);
    IF v_date IS NULL THEN
      RETURN NULL;
    END IF;
    
    RETURN TO_NUMBER(TO_CHAR(v_date, 'DD'));
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION day_(p_date_expr IN DATE)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(DAY FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION day_(p_date_expr IN TS)
RETURN NUMBER
IS
BEGIN
    RETURN EXTRACT(DAY FROM p_date_expr);
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END day_;

FUNCTION DAY_(P_DATE_EXPR    IN TSTZ) RETURN NUMBER
IS
BEGIN
    RETURN DAY_(CAST(p_date_expr AS TS));
END DAY_;

FUNCTION stuff(p_expr VARCHAR2, p_startIdx NUMBER, p_len NUMBER, p_replace_expr VARCHAR2) 
RETURN VARCHAR2
IS
BEGIN
       RETURN REPLACE(p_expr, SUBSTR(p_expr, p_startIdx, p_len), p_replace_expr);
EXCEPTION
        WHEN OTHERS THEN
          raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END stuff;
PROCEDURE commit_transaction
IS
BEGIN	
   IF trancount <= 1 THEN
        COMMIT;
   END IF;
   resetTrancount;
END commit_transaction;

--RETURN A NUMBER TO HELP REPLICATE @@TRANSTATE
FUNCTION  COMMIT_TRANSACTION_STATE RETURN NUMBER
IS
BEGIN	
   IF trancount <= 1 THEN
        COMMIT;
   END IF;
   resetTrancount;
   RETURN 1;
EXCEPTION WHEN OTHERS THEN
  RETURN 3;   
END COMMIT_TRANSACTION_STATE;

FUNCTION round_(p_expr NUMBER, p_len NUMBER, p_function NUMBER DEFAULT 0) 
RETURN NUMBER
IS
    v_ret_value NUMBER;
BEGIN
      IF p_function = 0 THEN
         v_ret_value := ROUND(p_expr, p_len);
      ELSE
         v_ret_value := TRUNC(p_expr, p_len);
      END IF;
      
      RETURN v_ret_value;
EXCEPTION
     WHEN OTHERS THEN
       raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END round_;

FUNCTION patindex(p_pattern IN VARCHAR2, p_expr IN VARCHAR2, p_format IN VARCHAR2)
RETURN NUMBER
IS
    v_search_pattern VARCHAR2(100);
    v_pos NUMBER := 0;
    v_charsfmt VARCHAR2(20) := 'using chars';
    v_charactersfmt  VARCHAR2(20) := 'using characters';
    v_bytesfmt VARCHAR2(20) := 'using bytes';
    v_format VARCHAR2(20);
    v_errmsg VARCHAR2(50) := 'Invalid format: ';
BEGIN
      IF p_pattern IS NULL OR p_expr IS NULL THEN
         RETURN NULL;
      END IF;
      
      IF NOT DBMS_DB_VERSION.VER_LE_9_2 THEN
        v_search_pattern := p_pattern;
        v_search_pattern := REPLACE(v_search_pattern, '\', '\\');
        v_search_pattern := REPLACE(v_search_pattern, '*', '\*');
        v_search_pattern := REPLACE(v_search_pattern, '+', '\+');
        v_search_pattern := REPLACE(v_search_pattern, '?', '\?');
        v_search_pattern := REPLACE(v_search_pattern, '|', '\|');
        v_search_pattern := REPLACE(v_search_pattern, '^', '\^');
        v_search_pattern := REPLACE(v_search_pattern, '$', '\$');
        v_search_pattern := REPLACE(v_search_pattern, '.', '\.');
        v_search_pattern := REPLACE(v_search_pattern, '{', '\{');
        v_search_pattern := REPLACE(v_search_pattern, '_', '.');
              
        v_format := lower(p_format);
        IF v_format = v_charsfmt OR v_format = v_charactersfmt THEN
           IF SUBSTR(v_search_pattern, 1, 1) != '%' AND 
              SUBSTR(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := '^' || v_search_pattern || '$';
           ELSIF SUBSTR(v_search_pattern, 1, 1) != '%' THEN
               v_search_pattern := '^' || SUBSTR(v_search_pattern, 1, LENGTH(v_search_pattern) - 1);
           ELSIF SUBSTR(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := SUBSTR(v_search_pattern, 2) || '$';
           ELSE
               v_search_pattern := SUBSTR(v_search_pattern, 2, LENGTH(v_search_pattern) - 2);
           END IF;    
        ELSIF v_format = v_bytesfmt THEN    
           IF SUBSTRB(v_search_pattern, 1, 1) != '%' AND 
              SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := '^' || v_search_pattern || '$';
           ELSIF SUBSTRB(v_search_pattern, 1, 1) != '%' THEN
               v_search_pattern := '^' || SUBSTRB(v_search_pattern, 1, LENGTHB(v_search_pattern) - 1);
           ELSIF SUBSTRB(v_search_pattern, -1, 1) != '%' THEN
               v_search_pattern := SUBSTRB(v_search_pattern, 2) || '$';
           ELSE
               v_search_pattern := SUBSTRB(v_search_pattern, 2, LENGTHB(v_search_pattern) - 2);
           END IF;    
        ELSE
            v_errmsg := v_errmsg || p_format;
            raise_application_error(-20001, v_errmsg);
        END IF;
        v_pos := REGEXP_INSTR(p_expr, v_search_pattern);
      ELSE 
        v_pos := 0;
      END IF;
      
      RETURN v_pos;
EXCEPTION
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END patindex;
PROCEDURE incrementTrancount
IS
BEGIN	
   trancount := trancount + 1;
END INCREMENTTRANCOUNT;

FUNCTION reverse_(p_expr IN VARCHAR2)
RETURN VARCHAR2
IS
    v_result VARCHAR2(2000) := NULL;
BEGIN      
    FOR i IN 1..LENGTH(p_expr) LOOP
      v_result := v_result || SUBSTR(p_expr, -i, 1);
    END LOOP;
  
    RETURN v_result;    
EXCEPTION 
    WHEN OTHERS THEN
      raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END reverse_;

PROCEDURE SET_DATABASE_TYPE (P_DATABASE_TYPE IN VARCHAR2)
AS
BEGIN
DATABASE_TYPE := P_DATABASE_TYPE;
END SET_DATABASE_TYPE;

FUNCTION SPID  RETURN NUMBER
AS 
BEGIN
RETURN USERENV('sessionid');
END;

FUNCTION STR(P_EXPR IN NUMBER, P_LEN IN NUMBER DEFAULT 10, P_SCALE IN NUMBER DEFAULT 0)  RETURN VARCHAR2
IS
    v_ret_val VARCHAR2(50);
    v_temp_val NUMBER;
    v_format_str VARCHAR2(50);
    v_len NUMBER;
    v_val NUMBER;
    v_has_decimal BOOLEAN := FALSE;
BEGIN
      IF INSTR(TO_CHAR(p_expr), '.') > 0 THEN
        v_has_decimal := TRUE;
        v_len := LENGTH(SUBSTR(TO_CHAR(p_expr), 1, INSTR(TO_CHAR(p_expr), '.')-1));
      ELSE
        v_len := LENGTH(TO_CHAR(p_expr));
      END IF;  
      
      IF p_len < v_len THEN
         RETURN TRIM(LPAD(' ', p_len+1,'*'));
      END IF;
      
      v_temp_val := p_expr;
      IF p_len >= v_len THEN
         v_temp_val := ROUND(v_temp_val, p_scale);
      ELSE
         v_temp_val := ROUND(v_temp_val, 0);
      END IF;   
      
      IF p_scale > 0 AND v_has_decimal THEN
         IF v_len >= (p_len - p_scale) THEN
             v_format_str := LPAD(' ', v_len+1, '9');
         ELSE    
             v_format_str := LPAD(' ', (p_len - p_scale), '9');
         END IF;
         v_format_str := TRIM(v_format_str);
         IF INSTR(TO_CHAR(p_expr), '.') != p_len THEN 
           v_format_str := v_format_str || '.';
           v_format_str := RPAD(v_format_str, p_len, '9');
         END IF;  
      ELSE
         v_format_str := TRIM(LPAD(' ', p_len+1, '9'));
      END IF;
      v_ret_val := TO_CHAR(v_temp_val, v_format_str);
      RETURN v_ret_val;
EXCEPTION 
      WHEN OTHERS THEN
        raise_application_error(-20000, DBMS_UTILITY.FORMAT_ERROR_STACK);
END STR;

PROCEDURE IDENTITY_RESET( V_IDENTITYID VARCHAR2) AS
BEGIN
identitymap(v_identityid) := 0;
END;

FUNCTION IDENTITY( V_IDENTITYID VARCHAR2, V_SEED  INT DEFAULT 1, V_INCREMENT  INT DEFAULT 1) RETURN NUMBER
as
  v_current number(20) := 0;
begin
  dbms_output.put_line('v_current1:'||v_current);
  begin
  v_current := identitymap(v_identityid);
  exception when others then
   v_current := 0;
  END;
  dbms_output.put_line('v_current2:'||v_Current);
  if v_current = 0 then
    identitymap(v_identityID):= 0;
  end if;
  v_current := identitymap(v_identityid);
  v_current := v_current + 1;
  identitymap(v_identityid) := v_current;
  return v_current;
end;

FUNCTION OBJECT_ID(objectref VARCHAR2) RETURN INT
AS
  ownerName  VARCHAR2(128);
  objectName VARCHAR2(128);
  objectId   INT;
BEGIN
  --select * from all_objects;
  --select object_id('system.redo_log') from dual;
  IF( INSTR(objectref,'.') = 0 )THEN
    ownerName             := NULL;
    objectName            := objectref;
  ELSE
    ownerName  := SUBSTR(objectref,0,INSTR(objectref,'.')-1);
    objectName := SUBSTR(objectref,INSTR(objectref,'.')  +1);
  END IF;
  BEGIN
    SELECT object_id
    INTO objectId
    FROM all_objects
    WHERE UPPER(owner)     = UPPER(NVL(ownerName,owner))
    AND  UPPER(object_name) = UPPER(objectName) ;
  EXCEPTION WHEN OTHERS THEN objectId := NULL;
  END;
  RETURN objectId;
END;

PROCEDURE RAISERROR(ERRORCODE NUMBER,MSG VARCHAR2)
AS
BEGIN
    -- NOTE: Oracle raise_application_error will terminate normal code flow , which T-SQL raiserror does not.
	-- raise_application_error(ERRORCODE||':'||MSG);
	DBMS_OUTPUT.PUT_LINE(ERRORCODE||':'||MSG);
END;

PROCEDURE HANDLEERROR(ERRORCODE NUMBER,MSG VARCHAR2)
AS
BEGIN
    -- NOTE: Oracle raise_application_error will terminate normal code flow , which T-SQL raiserror does not.
    raise_application_error(-20002,ERRORCODE||':'||MSG);
	--DBMS_OUTPUT.PUT_LINE(ERRORCODE||':'||MSG);
END;

FUNCTION error_line RETURN VARCHAR2
AS
BEGIN
 RETURN '0';
END;

FUNCTION error_procedure RETURN VARCHAR2
AS
BEGIN
 RETURN '0';
END;

FUNCTION error_severity RETURN VARCHAR2
AS
BEGIN
 RETURN '0';
END;

FUNCTION error_state RETURN VARCHAR2
AS
BEGIN
 RETURN '0';
END;

BEGIN

-- Datetime formats/styles starting with DAY only --
DT_DAY := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fxfmdd/mm/yy',                    --British/French
'fxfmdd/mm/yyyy',                  --British/French(with Century)
'fxfmdd.mm.yy',                    --German(without Century)
'fxfmdd.mm.yyyy',                  --German(with Century)
'fxfmdd-mm-yy',                    --Italian(without Century)
'fxfmdd-mm-yyyy',                  --Italian(with Century)
'fxfmdd mon yy',                   --(without Century)
'fxfmdd mon yyyy',                 --(with Century)
'dd mon yyyy hh24:mi:ssxff3',      --Europe default+milliseconds
'fxdd mon yyyy hh12:mi:ss:ff3AM',  --Hijri calendar system 
'fxdd/mm/yy hh12:mi:ss:ff3AM',     --Hijri calendar system 

-------- Some more DateTime formats that were addressed before --------
'fmdd yyyy MONTH',

----------------- Additional DateTime formats ------------------------- 
'fmdd Month',
'fmdd Month yy',
'fmdd Month yyyy',
'fxddmmyy',
'fxddmmyyyy',
'fxdd-Mon-yy',
'fxdd-MON-yy',
'fxdd-Mon-yyyy',
'fxdd-MON-yyyy'
);

-- Datetime formats/styles starting with MONTH only --
DT_MONTH := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fxfmmm/dd/yyyy hh24:mi:ss',       --SQLSERVER 101  
'fmmon dd yyyy hh:miAM',           --Default   
'fxfmmm/dd/yy',                    --US(without Century)
'fxfmmm/dd/yyyy',                  --US(with Century)
'fxfmMon dd, yy',                  --(without Century)
'fxfmMon dd, yyyy',                --(with Century)
'mon dd yyyy hh12:mi:ssxff3am',    --Default+milliseconds
'fxfmmm-dd-yy',                    --US(without Century)
'fxfmmm-dd-yyyy',                  --US(with Century)

-------- Some more DateTime formats that were addressed before -------- 
'fmMONTH, yyyy',
'MON yyyy',
'fmMONTH dd, yyyy',
----------------- Additional DateTime formats ------------------------- 
'mm/yy',
'mm/yyyy',
'fmMonth dd, yyyy',             
'fmMonth dd',
'mm-yy',
'mm-yyyy',
'fxmmddyy',
'fxmmddyyyy',
'Mon-yy',
'Mon-yyyy',
'MON-yy',
'MON-yyyy'
);

-- Datetime formats/styles starting with YEAR only --
DT_YEAR := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'fxfmyy.mm.dd',                    --ANSI(without Century)
'fxfmyyyy.mm.dd',                  --ANSI(with Century)
'fxfmyy/mm/dd',                    --Japan(without Century)
'fxfmyyyy/mm/dd',                  --Japan(with Century)
'yymmdd',                          --ISO(without Century)
'yyyymmdd',                        --ISO(with Century)
'fxyyyy-mm-dd hh24:mi:ss',         --ODBC canonical
'fxyyyy-mm-dd hh24:mi:ssxff3',     --ODBC canonical (with milliseconds)
'fxyyyy-mm-dd"T"hh12:mi:ssxff3',   --ISO8601 (no spaces)
'fxyyyy-mm-dd hh12:mi:ssxff3',     --ISO8601 (with space)

-------- Some more DateTime formats that were addressed before -------- 
'fxyyyymmdd hh24:mi:ss',
'fxyyyy-mm-dd',                    --ISO8601 Date only
'fxyyyy-mm-dd hh12:mi:ss',
'yyyy MON',

----------------- Additional DateTime formats ------------------------- 
'yy/mm',
'yyyy/mm',
'yy-mm',
'yyyy-mm'
);

-- TIME formats/styles --
DT_TIME := VARCHAR2_ARRAY(
----------- SQLServer and Sybase Datetime formats/styles --------------
----- Format/Style ------       ------ Standard ------ 
'hh:mi:ss',
'hh24:mi:ssxff3',

-------- Some more Time formats that were addressed before ------------ 
'hh12 AM',                         --Time using Hour
'hh12:mi:ss AM'                    --Time
);

-- ORACLE Server NLS DATETIME FORMATS --
DT_NLS := VARCHAR2_ARRAY(
getNLSDATEformat,
getNLSTSformat,
getNLSTSformat
);

-- TIME formats/styles --
DT_TIMESTAMP := VARCHAR2_ARRAY(
'fxfmmm/dd/yyyy hh24:mi:ss.ff9',
'yyyy-mm-dd hh24:mi:ss.ff9'
);
/*
 You can modify the DT_FORMATS as you wish.
 Put the most likely Datetime Formats or 
 Nested Table Type variables at the top.
 For e.g: 
   DT_FORMATS := DT_MONTH MULTISET UNION DT_NLS;
   DT_FORMATS := DT_YEAR MULTISET UNION DT_TIME;
   DT_FORMATS := VARCHAR2_ARRAY('mm-dd-yy');
*/
DT_FORMATS := DT_MONTH MULTISET UNION DT_YEAR MULTISET UNION DT_NLS MULTISET UNION DT_TIMESTAMP;

END utils;
/

GRANT ALL ON utils TO ROLE_lab6_2;
grant ALL on utils to TravelAgency with grant option;

set define on
prompt connecting to TravelAgency
alter session set current_schema=TravelAgency;
set define off
-- DROP TABLE Report CASCADE CONSTRAINTS;


PROMPT Creating Table Report ...
CREATE TABLE Report (
  id NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  xml_column CLOB
);


PROMPT Creating Primary Key Constraint PK__Report__3213E83F11960C3D on table Report ... 
ALTER TABLE Report
ADD CONSTRAINT PK__Report__3213E83F11960C3D PRIMARY KEY
(
  id
)
ENABLE
;

GRANT ALL ON Report TO ROLE_lab6_2;
-- DROP TABLE geometry_columns CASCADE CONSTRAINTS;


PROMPT Creating Table geometry_columns ...
CREATE TABLE geometry_columns (
  f_table_catalog VARCHAR2(128 CHAR) NOT NULL,
  f_table_schema VARCHAR2(128 CHAR) NOT NULL,
  f_table_name VARCHAR2(256 CHAR) NOT NULL,
  f_geometry_column VARCHAR2(256 CHAR) NOT NULL,
  coord_dimension NUMBER(10,0) NOT NULL,
  srid NUMBER(10,0) NOT NULL,
  geometry_type VARCHAR2(30 CHAR) NOT NULL
);


PROMPT Creating Primary Key Constraint geometry_columns_pk on table geometry_columns ... 
ALTER TABLE geometry_columns
ADD CONSTRAINT geometry_columns_pk PRIMARY KEY
(
  f_table_catalog,
  f_table_schema,
  f_table_name,
  f_geometry_column
)
ENABLE
;

GRANT ALL ON geometry_columns TO ROLE_lab6_2;
-- DROP TABLE spatial_ref_sys CASCADE CONSTRAINTS;


PROMPT Creating Table spatial_ref_sys ...
CREATE TABLE spatial_ref_sys (
  srid NUMBER(10,0) NOT NULL,
  auth_name VARCHAR2(256 CHAR),
  auth_srid NUMBER(10,0),
  srtext VARCHAR2(2048 CHAR),
  proj4text VARCHAR2(2048 CHAR)
);


PROMPT Creating Primary Key Constraint PK__spatial___36B11BD5882B545B on table spatial_ref_sys ... 
ALTER TABLE spatial_ref_sys
ADD CONSTRAINT PK__spatial___36B11BD5882B545B PRIMARY KEY
(
  srid
)
ENABLE
;

GRANT ALL ON spatial_ref_sys TO ROLE_lab6_2;
-- DROP TABLE world_countries CASCADE CONSTRAINTS;


PROMPT Creating Table world_countries ...
CREATE TABLE world_countries (
  ogr_fid NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  ogr_geometry RAW(8000),
  country NCLOB
);


PROMPT Creating Primary Key Constraint PK_world_countries on table world_countries ... 
ALTER TABLE world_countries
ADD CONSTRAINT PK_world_countries PRIMARY KEY
(
  ogr_fid
)
ENABLE
;

GRANT ALL ON world_countries TO ROLE_lab6_2;
-- DROP TABLE Countries CASCADE CONSTRAINTS;


PROMPT Creating Table Countries ...
CREATE TABLE Countries (
  idCountry NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  country NVARCHAR2(50),
  visa NUMBER(1,0),
  CountryMap NUMBER(10,0)
);


PROMPT Creating Primary Key Constraint PK__Countrie__85364809F08B29E4 on table Countries ... 
ALTER TABLE Countries
ADD CONSTRAINT PK__Countrie__85364809F08B29E4 PRIMARY KEY
(
  idCountry
)
ENABLE
;

GRANT ALL ON Countries TO ROLE_lab6_2;
-- DROP TABLE Touroperators CASCADE CONSTRAINTS;


PROMPT Creating Table Touroperators ...
CREATE TABLE Touroperators (
  idOperator NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  name NVARCHAR2(150),
  phoneNumber NVARCHAR2(11)
);


PROMPT Creating Primary Key Constraint PK__Touroper__DDFD096531A086F3 on table Touroperators ... 
ALTER TABLE Touroperators
ADD CONSTRAINT PK__Touroper__DDFD096531A086F3 PRIMARY KEY
(
  idOperator
)
ENABLE
;

GRANT ALL ON Touroperators TO ROLE_lab6_2;
-- DROP TABLE Tours CASCADE CONSTRAINTS;


PROMPT Creating Table Tours ...
CREATE TABLE Tours (
  idTours NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  idCountry NUMBER(10,0),
  idOperator NUMBER(10,0),
  tourName NVARCHAR2(255),
  descr NVARCHAR2(255),
  tourRoute RAW(8000)
);


PROMPT Creating Primary Key Constraint PK__Tours__830A40D215C1473A on table Tours ... 
ALTER TABLE Tours
ADD CONSTRAINT PK__Tours__830A40D215C1473A PRIMARY KEY
(
  idTours
)
ENABLE
;

GRANT ALL ON Tours TO ROLE_lab6_2;
-- DROP TABLE Vouchers CASCADE CONSTRAINTS;


PROMPT Creating Table Vouchers ...
CREATE TABLE Vouchers (
  idVoucher NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  idTour NUMBER(10,0),
  voucherName NVARCHAR2(255),
  descr NVARCHAR2(255),
  price NUMBER(19,4),
  numberOfPeople NUMBER(10,0),
  nutrition NUMBER(1,0),
  accommodation NUMBER(1,0),
  hot NUMBER(1,0),
  discount NUMBER(10,0),
  node RAW(8000),
  position NUMBER(10,0),
  LEVEL_ NUMBER(5,0)
);


COMMENT ON COLUMN Vouchers.LEVEL_ IS 'ORIGINAL NAME:LEVEL'
;

PROMPT Creating Primary Key Constraint PK__Vouchers__BD9AA6BEB1AB7B12 on table Vouchers ... 
ALTER TABLE Vouchers
ADD CONSTRAINT PK__Vouchers__BD9AA6BEB1AB7B12 PRIMARY KEY
(
  idVoucher
)
ENABLE
;

GRANT ALL ON Vouchers TO ROLE_lab6_2;
-- DROP TABLE Orders CASCADE CONSTRAINTS;


PROMPT Creating Table Orders ...
CREATE TABLE Orders (
  idOrder NUMBER(10,0) GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 1 INCREMENT BY 1 MINVALUE 1 NOMAXVALUE ,
  idVoucher NUMBER(10,0),
  customer NVARCHAR2(255),
  pay NUMBER(1,0)
);


PROMPT Creating Primary Key Constraint PK__Orders__C8AAF6FF6CCC0122 on table Orders ... 
ALTER TABLE Orders
ADD CONSTRAINT PK__Orders__C8AAF6FF6CCC0122 PRIMARY KEY
(
  idOrder
)
ENABLE
;

GRANT ALL ON Orders TO ROLE_lab6_2;
PROMPT Creating Index My_XML_Index on Report ...
CREATE INDEX My_XML_Index ON Report
(
  xml_column
)  INDEXTYPE is ctxsys.context
;
PROMPT Creating Index IDX_WORLD_COUNTRIES_GEOM_1 on world_countries ...
CREATE INDEX IDX_WORLD_COUNTRIES_GEOM_1 ON world_countries
(
  ogr_geometry
) 
;
PROMPT Creating Index Tours_index on Tours ...
CREATE INDEX Tours_index ON Tours
(
  tourName
) 
;
PROMPT Creating Index Voucher_index on Vouchers ...
CREATE INDEX Voucher_index ON Vouchers
(
  voucherName
) 
;
PROMPT Creating Index Order_index on Orders ...
CREATE INDEX Order_index ON Orders
(
  customer
) 
;
create or replace SYNONYM utils for "EMULATION".utils;



set define on
prompt connecting to TravelAgency
alter session set current_schema=TravelAgency;
set define off
CREATE OR REPLACE FORCE VIEW CustomerVoucher 
AS 
   SELECT O.customer ,
          V.voucherName 
     FROM Orders O
            JOIN Vouchers V   ON O.idVoucher = V.idVoucher;


GRANT ALL ON CustomerVoucher TO ROLE_lab6_2;
CREATE OR REPLACE FORCE VIEW NumberPeopleTour 
AS 
   SELECT T.tourName ,
          V.numberOfPeople 
     FROM Vouchers V
            JOIN Tours T   ON V.idTour = T.idTours;


GRANT ALL ON NumberPeopleTour TO ROLE_lab6_2;
CREATE OR REPLACE FORCE VIEW CuctomerOperator 
AS 
   SELECT O.customer ,
          TR.name ,
          TR.phoneNumber ,
          T.tourName ,
          T.descr ,
          V.price 
     FROM Orders O
            JOIN Vouchers V   ON O.idVoucher = V.idVoucher
            JOIN Tours T   ON V.idTour = T.idTours
            JOIN Touroperators TR   ON T.idOperator = TR.idOperator;


GRANT ALL ON CuctomerOperator TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION CountTour
(
  v_idCountry IN NUMBER
)
RETURN NUMBER
AS
   v_res NUMBER(10,0);
-- Returns the stock level for the product.

BEGIN
   SELECT COUNT(idTours)  

     INTO v_res
     FROM Tours 
    WHERE  Tours.idCountry = v_idCountry;
   IF ( v_res IS NULL ) THEN
    v_res := 0 ;
   END IF;
   RETURN v_res;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON CountTour TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.fn_diagramobjects
RETURN NUMBER
AUTHID DEFINER
AS
   v_id_upgraddiagrams NUMBER(10,0);
   v_id_sysdiagrams NUMBER(10,0);
   v_id_helpdiagrams NUMBER(10,0);
   v_id_helpdiagramdefinition NUMBER(10,0);
   v_id_creatediagram NUMBER(10,0);
   v_id_renamediagram NUMBER(10,0);
   v_id_alterdiagram NUMBER(10,0);
   v_id_dropdiagram NUMBER(10,0);
   v_InstalledObjects NUMBER(10,0);

BEGIN
   v_InstalledObjects := 0 ;
   v_id_upgraddiagrams := utils.object_id(N'dbo.sp_upgraddiagrams') ;
   v_id_sysdiagrams := utils.object_id(N'dbo.sysdiagrams') ;
   v_id_helpdiagrams := utils.object_id(N'dbo.sp_helpdiagrams') ;
   v_id_helpdiagramdefinition := utils.object_id(N'dbo.sp_helpdiagramdefinition') ;
   v_id_creatediagram := utils.object_id(N'dbo.sp_creatediagram') ;
   v_id_renamediagram := utils.object_id(N'dbo.sp_renamediagram') ;
   v_id_alterdiagram := utils.object_id(N'dbo.sp_alterdiagram') ;
   v_id_dropdiagram := utils.object_id(N'dbo.sp_dropdiagram') ;
   IF v_id_upgraddiagrams IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 1 ;
   END IF;
   IF v_id_sysdiagrams IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 2 ;
   END IF;
   IF v_id_helpdiagrams IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 4 ;
   END IF;
   IF v_id_helpdiagramdefinition IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 8 ;
   END IF;
   IF v_id_creatediagram IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 16 ;
   END IF;
   IF v_id_renamediagram IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 32 ;
   END IF;
   IF v_id_alterdiagram IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 64 ;
   END IF;
   IF v_id_dropdiagram IS NOT NULL THEN
    v_InstalledObjects := v_InstalledObjects + 128 ;
   END IF;
   RETURN v_InstalledObjects;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON fn_diagramobjects TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION SelectNumberOperator
(
  v_name IN NVARCHAR2
)
RETURN NVARCHAR2
AS
   v_temp NVARCHAR2(255);

BEGIN
   SELECT phoneNumber 

     INTO v_temp
     FROM Touroperators 
    WHERE  NAME = v_name;
   RETURN v_temp;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON SelectNumberOperator TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION SelectTours
(
  v_idCountry IN NUMBER
)
RETURN NVARCHAR2
AS
   v_temp NVARCHAR2(255);

BEGIN
   SELECT tourName 

     INTO v_temp
     FROM Tours 
    WHERE  idTours = v_idCountry;
   RETURN v_temp;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON SelectTours TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE addCountries
(
  v_country IN NVARCHAR2,
  v_visa IN NUMBER,
  v_countryMapId IN NUMBER
)
AS

BEGIN

   INSERT INTO Countries
     ( country, visa, CountryMap )
     VALUES ( v_country, v_visa, v_countryMapId );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON addCountries TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE addOperator
---- Operators

(
  v_name IN NVARCHAR2,
  v_phoneNumber IN NVARCHAR2
)
AS

BEGIN

   INSERT INTO Touroperators
     ( NAME, phoneNumber )
     VALUES ( v_name, v_phoneNumber );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON addOperator TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE AddOrders
------Orders-------------------------------

(
  v_idVoucher IN NUMBER,
  v_customer IN NVARCHAR2,
  v_pay IN NUMBER
)
AS

BEGIN

   INSERT INTO Orders
     ( idVoucher, customer, pay )
     VALUES ( v_idVoucher, v_customer, v_pay );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON AddOrders TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE AddTour
---- Tours----------------------------------------

(
  v_idCountry IN NUMBER,
  v_idOperator IN NUMBER,
  v_tourName IN NVARCHAR2,
  v_descr IN NVARCHAR2
)
AS

BEGIN

   INSERT INTO Tours
     ( idCountry, idOperator, tourName, descr )
     VALUES ( v_idCountry, v_idOperator, v_tourName, v_descr );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON AddTour TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE AddVoucher
(
  v_idTour IN NUMBER,
  v_voucherName IN NVARCHAR2,
  v_descr IN NVARCHAR2,
  v_price IN NUMBER,
  v_numberOfPeople IN NUMBER,
  v_nutrition IN NUMBER,
  v_accommodation IN NUMBER,
  v_hot IN NUMBER,
  v_discount IN NUMBER
)
AS

BEGIN

   INSERT INTO Vouchers
     ( idTour, voucherName, descr, price, numberOfPeople, nutrition, accommodation, hot, discount )
     VALUES ( v_idTour, v_voucherName, v_descr, v_price, v_numberOfPeople, v_nutrition, v_accommodation, v_hot, v_discount );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON AddVoucher TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE CalculateTourIntersection
(
  v_tourId1 IN NUMBER,
  v_tourId2 IN NUMBER
)
AS
   v_tour1Route UDT.GEOMETRY%TYPE;
   v_tour2Route UDT.GEOMETRY%TYPE;
   v_intersection UDT.GEOMETRY%TYPE;
   v_cursor SYS_REFCURSOR;

BEGIN

   SELECT tourRoute 

     INTO v_tour1Route
     FROM Tours 
    WHERE  idTours = v_tourId1;
   SELECT tourRoute 

     INTO v_tour2Route
     FROM Tours 
    WHERE  idTours = v_tourId2;
   v_intersection := v_tour1Route ;
   STIntersection(v_tour2Route) ;
   OPEN  v_cursor FOR
      SELECT v_intersection ( ) AS intersection ;  --SQLDEV: NOT RECOGNIZED 
        FROM DUAL  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON CalculateTourIntersection TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE DeleteCountry
(
  v_country IN NVARCHAR2
)
AS

BEGIN

   DELETE Countries

    WHERE  country = v_country;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON DeleteCountry TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE DeleteOperator
(
  v_name IN NVARCHAR2
)
AS

BEGIN

   DELETE Touroperators

    WHERE  NAME = v_name;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON DeleteOperator TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE DeleteOrder
(
  v_customer IN NVARCHAR2
)
AS

BEGIN

   DELETE Orders

    WHERE  customer = v_customer;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON DeleteOrder TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE DeleteTour
(
  v_idTours IN NUMBER
)
AS

BEGIN

   DELETE Tours

    WHERE  idTours = v_idTours;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON DeleteTour TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE DeleteVoucher
(
  v_voucherName IN NVARCHAR2
)
AS

BEGIN

   DELETE Vouchers

    WHERE  voucherName = v_voucherName;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON DeleteVoucher TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE generateXML
AS
   v_x CLOB;
   v_cursor SYS_REFCURSOR;

BEGIN

   SELECT t.tourName _  ,
          v.voucherName _  ,
          tro.NAME _  ,
          SYSDATE   

     INTO v_x
     FROM Vouchers v
            JOIN Tours t   ON v.idTour = t.idTours
            JOIN Touroperators tro   ON tro.idOperator = t.idOperator;
   OPEN  v_cursor FOR
      SELECT v_x 
        FROM DUAL  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON generateXML TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE getCountries
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Countries  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON getCountries TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE getCountriesByName
(
  v_country IN NVARCHAR2
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Countries 
       WHERE  country = v_country ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON getCountriesByName TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE gethierarchyById
(
  v_id IN UDT.HIERARCHYID%TYPE
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   --  
   OPEN  v_cursor FOR
      SELECT ToString() string  ,
             GetLevel() level_  ,
             * 
        FROM Vouchers 
       WHERE  IsDescendantOf(v_id) = 1 ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON gethierarchyById TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetOperatorByName
(
  v_name IN NVARCHAR2
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Touroperators 
       WHERE  NAME = v_name ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetOperatorByName TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetOperators
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Touroperators  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetOperators TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetOrderByCustomer
(
  v_customer IN NVARCHAR2
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Orders 
       WHERE  customer = v_customer ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetOrderByCustomer TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetOrders
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Orders  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetOrders TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetTourByName
(
  v_tourName IN NVARCHAR2
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Tours 
       WHERE  tourName = v_tourName ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetTourByName TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetTourDistance
(
  v_tourId1 IN NUMBER,
  v_tourId2 IN NUMBER
)
AS
   v_route1 UDT.GEOMETRY%TYPE;
   v_route2 UDT.GEOMETRY%TYPE;
   v_distance FLOAT(53);

BEGIN

   -- Get the tour routes for the given tour IDs
   SELECT tourRoute 

     INTO v_route1
     FROM Tours 
    WHERE  idTours = v_tourId1;
   SELECT tourRoute 

     INTO v_route2
     FROM Tours 
    WHERE  idTours = v_tourId2;
   -- Calculate the distance between the routes
   v_distance := v_route1 ;
   STDistance(v_route2) ;
   -- Print the result
   DBMS_OUTPUT.PUT_LINE(v_distance);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetTourDistance TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetTours
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Tours  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetTours TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetVoucherByName
(
  v_voucherName IN NVARCHAR2
)
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Vouchers 
       WHERE  voucherName = v_voucherName ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetVoucherByName TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE GetVouchers
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Vouchers  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON GetVouchers TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE InsertInReport
AS
   v_s CLOB;

BEGIN

   SELECT t.tourName _  ,
          v.voucherName _  ,
          tro.NAME _  ,
          SYSDATE   

     INTO v_s
     FROM Vouchers v
            JOIN Tours t   ON v.idTour = t.idTours
            JOIN Touroperators tro   ON tro.idOperator = t.idOperator;
   --FOR XML AUTO, TYPE);
   INSERT INTO Report
     VALUES ( DEFAULT, v_s );

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON InsertInReport TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE insertValue
(
  v_hid IN UDT.HIERARCHYID%TYPE,
  v_idTour IN NUMBER,
  v_voucherName IN NVARCHAR2,
  v_descr IN NVARCHAR2,
  v_price IN NUMBER,
  v_numberOfPeople IN NUMBER,
  v_nutrition IN NUMBER,
  v_accommodation IN NUMBER,
  v_hot IN NUMBER,
  v_discount IN NUMBER
)
AS
   v_LCV UDT.HIERARCHYID%TYPE;

BEGIN

   --SQL Server BEGIN TRANSACTION;
   utils.incrementTrancount;
   SELECT MAX(node)  

     INTO v_LCV
     FROM Vouchers 
    WHERE  GetAncestor(1) = v_HID;INTO Vouchers ( node , idTour , voucherName , descr , price , numberOfPeople , nutrition , accommodation , hot , discount ) VALUES ( @HID . GetDescendant ( @LCV , NULL ) , @idTour , @voucherName , @descr , @price , @numberOfPeople , @nutrition , @accommodation , @hot , @discount ) ;  --SQLDEV: NOT RECOGNIZED
   utils.commit_transaction;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON insertValue TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE MoveBranche
(
  v_oldparent IN UDT.HIERARCHYID%TYPE,
  v_newparent IN UDT.HIERARCHYID%TYPE
)
AS
   v_sys_error NUMBER := 0;

BEGIN

   DECLARE
      v_ChildId UDT.HIERARCHYID%TYPE;
      CURSOR children_cursor
        IS SELECT node 
        FROM Vouchers 
       WHERE  GetAncestor(1) = v_OldParent;
   
   BEGIN
      OPEN children_cursor;
      FETCH children_cursor INTO v_ChildId;
      Vouchers WHERE node . GetAncestor ( 1 ) = @NewParent ;  --SQLDEV: NOT RECOGNIZED
      BEGIN
         UPDATE Vouchers

            --     
            SET node = GetReparentedValue(v_ChildId, v_NewId)
          WHERE  IsDescendantOf(v_ChildId) = 1;
      EXCEPTION WHEN OTHERS THEN
            v_sys_error := SQLCODE;
      END;
      IF v_sys_error <> 0 THEN
       GOTO START;
      END IF;
      v_sys_error := 0;
      FETCH children_cursor INTO v_ChildId;
   
   END;
   CLOSE children_cursor;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON MoveBranche TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE SelectData
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT /*TODO:SQLDEV*/ xml_column.query('/row') /*END:SQLDEV*/ xml_column  
        FROM Report  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON SelectData TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.sp_alterdiagram
(
  v_diagramname IN VARCHAR2,
  iv_owner_id IN NUMBER DEFAULT NULL ,
  v_version IN NUMBER,
  v_definition IN RAW
)
RETURN NUMBER
AUTHID DEFINER
AS
   v_owner_id NUMBER(10,0) := iv_owner_id;
   v_theId NUMBER(10,0);
   v_retval NUMBER(10,0);
   v_IsDbo NUMBER(10,0);
   v_UIDFound NUMBER(10,0);
   v_DiagId NUMBER(10,0);
   v_ShouldChangeUID NUMBER(10,0);

BEGIN

   IF ( v_diagramname IS NULL ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Invalid ARG' );
      RETURN -1;
   
   END;
   END IF;
   /*TODO:SQLDEV*/ execute as caller /*END:SQLDEV*/
   v_theId := DATABASE_PRINCIPAL_ID() ;
   v_IsDbo := /*TODO:SQLDEV*/ IS_MEMBER(N'db_owner') /*END:SQLDEV*/ ;
   IF ( v_owner_id IS NULL ) THEN
    v_owner_id := v_theId ;
   END IF;
   /*TODO:SQLDEV*/ revert /*END:SQLDEV*/
   v_ShouldChangeUID := 0 ;
   SELECT diagram_id ,
          principal_id 

     INTO v_DiagId,
          v_UIDFound
     FROM TravelAgency.sysdiagrams 
    WHERE  principal_id = v_owner_id
             AND NAME = v_diagramname;
   IF ( v_DiagId IS NULL
     OR ( v_IsDbo = 0
     AND v_theId <> v_UIDFound ) ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Diagram does not exist or you do not have permission.' );
      RETURN -3;
   
   END;
   END IF;
   IF ( v_IsDbo <> 0 ) THEN
    
   BEGIN
      IF ( v_UIDFound IS NULL
        OR USER IS NULL ) THEN
       
       -- invalid principal_id
      BEGIN
         v_ShouldChangeUID := 1 ;
      
      END;
      END IF;
   
   END;
   END IF;
   -- update dds data			
   UPDATE TravelAgency.sysdiagrams
      SET DEFINITION = v_definition
    WHERE  diagram_id = v_DiagId;
   -- change owner
   IF ( v_ShouldChangeUID = 1 ) THEN
    UPDATE TravelAgency.sysdiagrams
      SET principal_id = v_theId
    WHERE  diagram_id = v_DiagId;
   END IF;
   -- update dds version
   IF ( v_version IS NOT NULL ) THEN
    UPDATE TravelAgency.sysdiagrams
      SET version = v_version
    WHERE  diagram_id = v_DiagId;
   END IF;
   RETURN 0;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_alterdiagram TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.sp_creatediagram
(
  v_diagramname IN VARCHAR2,
  iv_owner_id IN NUMBER DEFAULT NULL ,
  v_version IN NUMBER,
  v_definition IN RAW
)
RETURN NUMBER
AUTHID DEFINER
AS
   v_owner_id NUMBER(10,0) := iv_owner_id;
   v_theId NUMBER(10,0);
   v_retval NUMBER(10,0);
   v_IsDbo NUMBER(10,0);
   v_userName VARCHAR2(128);
   v_temp NUMBER(1, 0) := 0;

BEGIN

   IF ( v_version IS NULL
     OR v_diagramname IS NULL ) THEN
    
   BEGIN
      utils.raiserror( 0, N'E_INVALIDARG' );
      RETURN -1;
   
   END;
   END IF;
   /*TODO:SQLDEV*/ execute as caller /*END:SQLDEV*/
   v_theId := DATABASE_PRINCIPAL_ID() ;
   v_IsDbo := /*TODO:SQLDEV*/ IS_MEMBER(N'db_owner') /*END:SQLDEV*/ ;
   /*TODO:SQLDEV*/ revert /*END:SQLDEV*/
   IF v_owner_id IS NULL THEN
    
   BEGIN
      v_owner_id := v_theId ;
   
   END;
   ELSE
   
   BEGIN
      IF v_theId <> v_owner_id THEN
       
      BEGIN
         IF v_IsDbo = 0 THEN
          
         BEGIN
            utils.raiserror( 0, N'E_INVALIDARG' );
            RETURN -1;
         
         END;
         END IF;
         v_theId := v_owner_id ;
      
      END;
      END IF;
   
   END;
   END IF;
   -- next 2 line only for test, will be removed after define name unique
   BEGIN
      SELECT 1 INTO v_temp
        FROM DUAL
       WHERE EXISTS ( SELECT diagram_id 
                      FROM TravelAgency.sysdiagrams 
                       WHERE  principal_id = v_theId
                                AND NAME = v_diagramname );
   EXCEPTION
      WHEN OTHERS THEN
         NULL;
   END;
      
   IF v_temp = 1 THEN
    
   BEGIN
      utils.raiserror( 0, 'The name is already used.' );
      RETURN -2;
   
   END;
   END IF;
   INSERT INTO TravelAgency.sysdiagrams
     ( NAME, principal_id, version, DEFINITION )
     VALUES ( v_diagramname, v_theId, v_version, v_definition );
   v_retval := utils.getidentity ;
   RETURN v_retval;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_creatediagram TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.sp_dropdiagram
(
  v_diagramname IN VARCHAR2,
  iv_owner_id IN NUMBER DEFAULT NULL 
)
RETURN NUMBER
AUTHID DEFINER
AS
   v_owner_id NUMBER(10,0) := iv_owner_id;
   v_theId NUMBER(10,0);
   v_IsDbo NUMBER(10,0);
   v_UIDFound NUMBER(10,0);
   v_DiagId NUMBER(10,0);

BEGIN

   IF ( v_diagramname IS NULL ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Invalid value' );
      RETURN -1;
   
   END;
   END IF;
   /*TODO:SQLDEV*/ EXECUTE AS CALLER /*END:SQLDEV*/
   v_theId := DATABASE_PRINCIPAL_ID() ;
   v_IsDbo := /*TODO:SQLDEV*/ IS_MEMBER(N'db_owner') /*END:SQLDEV*/ ;
   IF ( v_owner_id IS NULL ) THEN
    v_owner_id := v_theId ;
   END IF;
   /*TODO:SQLDEV*/ REVERT /*END:SQLDEV*/
   SELECT diagram_id ,
          principal_id 

     INTO v_DiagId,
          v_UIDFound
     FROM TravelAgency.sysdiagrams 
    WHERE  principal_id = v_owner_id
             AND NAME = v_diagramname;
   IF ( v_DiagId IS NULL
     OR ( v_IsDbo = 0
     AND v_UIDFound <> v_theId ) ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Diagram does not exist or you do not have permission.' );
      RETURN -3;
   
   END;
   END IF;
   DELETE TravelAgency.sysdiagrams

    WHERE  diagram_id = v_DiagId;
   RETURN 0;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_dropdiagram TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.sp_helpdiagramdefinition
(
  v_diagramname IN VARCHAR2,
  iv_owner_id IN NUMBER DEFAULT NULL 
)
RETURN NUMBER
AUTHID DEFINER
AS
   v_owner_id NUMBER(10,0) := iv_owner_id;
   v_theId NUMBER(10,0);
   v_IsDbo NUMBER(10,0);
   v_DiagId NUMBER(10,0);
   v_UIDFound NUMBER(10,0);
   v_cursor SYS_REFCURSOR;

BEGIN

   IF ( v_diagramname IS NULL ) THEN
    
   BEGIN
      utils.raiserror( 0, N'E_INVALIDARG' );
      RETURN -1;
   
   END;
   END IF;
   /*TODO:SQLDEV*/ execute as caller /*END:SQLDEV*/
   v_theId := DATABASE_PRINCIPAL_ID() ;
   v_IsDbo := /*TODO:SQLDEV*/ IS_MEMBER(N'db_owner') /*END:SQLDEV*/ ;
   IF ( v_owner_id IS NULL ) THEN
    v_owner_id := v_theId ;
   END IF;
   /*TODO:SQLDEV*/ revert /*END:SQLDEV*/
   SELECT diagram_id ,
          principal_id 

     INTO v_DiagId,
          v_UIDFound
     FROM TravelAgency.sysdiagrams 
    WHERE  principal_id = v_owner_id
             AND NAME = v_diagramname;
   IF ( v_DiagId IS NULL
     OR ( v_IsDbo = 0
     AND v_UIDFound <> v_theId ) ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Diagram does not exist or you do not have permission.' );
      RETURN -3;
   
   END;
   END IF;
   OPEN  v_cursor FOR
      SELECT version ,
             DEFINITION 
        FROM TravelAgency.sysdiagrams 
       WHERE  diagram_id = v_DiagId ;
      DBMS_SQL.RETURN_RESULT(v_cursor);
   RETURN 0;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_helpdiagramdefinition TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE TravelAgency.sp_helpdiagrams
(
  v_diagramname IN VARCHAR2 DEFAULT NULL ,
  v_owner_id IN NUMBER DEFAULT NULL 
)AUTHID DEFINER
AS
   v_user VARCHAR2(128);
   v_dboLogin NUMBER(1,0);
   v_cursor SYS_REFCURSOR;

BEGIN

   /*TODO:SQLDEV*/ EXECUTE AS CALLER /*END:SQLDEV*/
   v_user := USER ;
   v_dboLogin := UTILS.CONVERT_TO_NUMBER(/*TODO:SQLDEV*/ IS_MEMBER('db_owner') /*END:SQLDEV*/,1,0) ;
   /*TODO:SQLDEV*/ REVERT /*END:SQLDEV*/
   OPEN  v_cursor FOR
      SELECT SYS_CONTEXT('USERENV','') Database  ,
             NAME Name  ,
             diagram_id ID  ,
             USER Owner  ,
             principal_id OwnerID  
        FROM sysdiagrams 
       WHERE  ( v_dboLogin = 1
                OR USER = v_user )
                AND ( v_diagramname IS NULL
                OR NAME = v_diagramname )
                AND ( v_owner_id IS NULL
                OR principal_id = v_owner_id )
        ORDER BY 4,
                 5,
                 1 ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_helpdiagrams TO ROLE_lab6_2;
CREATE OR REPLACE FUNCTION TravelAgency.sp_renamediagram
(
  v_diagramname IN VARCHAR2,
  iv_owner_id IN NUMBER DEFAULT NULL ,
  v_new_diagramname IN VARCHAR2
)
RETURN NUMBER
AUTHID DEFINER
AS
   v_owner_id NUMBER(10,0) := iv_owner_id;
   v_theId NUMBER(10,0);
   v_IsDbo NUMBER(10,0);
   v_UIDFound NUMBER(10,0);
   v_DiagId NUMBER(10,0);
   v_DiagIdTarg NUMBER(10,0);
   v_u_name VARCHAR2(128);

BEGIN

   IF ( ( v_diagramname IS NULL )
     OR ( v_new_diagramname IS NULL ) ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Invalid value' );
      RETURN -1;
   
   END;
   END IF;
   /*TODO:SQLDEV*/ EXECUTE AS CALLER /*END:SQLDEV*/
   v_theId := DATABASE_PRINCIPAL_ID() ;
   v_IsDbo := /*TODO:SQLDEV*/ IS_MEMBER(N'db_owner') /*END:SQLDEV*/ ;
   IF ( v_owner_id IS NULL ) THEN
    v_owner_id := v_theId ;
   END IF;
   /*TODO:SQLDEV*/ REVERT /*END:SQLDEV*/
   v_u_name := USER ;
   SELECT diagram_id ,
          principal_id 

     INTO v_DiagId,
          v_UIDFound
     FROM TravelAgency.sysdiagrams 
    WHERE  principal_id = v_owner_id
             AND NAME = v_diagramname;
   IF ( v_DiagId IS NULL
     OR ( v_IsDbo = 0
     AND v_UIDFound <> v_theId ) ) THEN
    
   BEGIN
      utils.raiserror( 0, 'Diagram does not exist or you do not have permission.' );
      RETURN -3;
   
   END;
   END IF;
   -- if((@u_name is not null) and (@new_diagramname = @diagramname))	-- nothing will change
   --	return 0;
   IF ( v_u_name IS NULL ) THEN
    SELECT diagram_id 

     INTO v_DiagIdTarg
     FROM TravelAgency.sysdiagrams 
    WHERE  principal_id = v_theId
             AND NAME = v_new_diagramname;
   ELSE
      SELECT diagram_id 

        INTO v_DiagIdTarg
        FROM TravelAgency.sysdiagrams 
       WHERE  principal_id = v_owner_id
                AND NAME = v_new_diagramname;
   END IF;
   IF ( ( v_DiagIdTarg IS NOT NULL )
     AND v_DiagId <> v_DiagIdTarg ) THEN
    
   BEGIN
      utils.raiserror( 0, 'The name is already used.' );
      RETURN -2;
   
   END;
   END IF;
   IF ( v_u_name IS NULL ) THEN
    UPDATE TravelAgency.sysdiagrams
      SET name = v_new_diagramname,
          principal_id = v_theId
    WHERE  diagram_id = v_DiagId;
   ELSE
      UPDATE TravelAgency.sysdiagrams
         SET name = v_new_diagramname
       WHERE  diagram_id = v_DiagId;
   END IF;
   RETURN 0;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_renamediagram TO ROLE_lab6_2;
/* Translation Extracted DDL For Required Objects*/
CREATE TABLE TravelAgency.sysdiagrams
(
  NAME VARCHAR2(128) NOT NULL,
  principal_id NUMBER(10,0) NOT NULL,
  diagram_id NUMBER(10,0) PRIMARY KEY,
  version NUMBER(10,0) ,
  DEFINITION RAW CONSTRAINT UK_principal_name ,UNIQUE( principal_id,NAME )
);
/
CREATE SEQUENCE tt_TravelAgency.sysdiagrams 
;
/
CREATE OR REPLACE TRIGGER 
 tt_TR_velAgency.sysdiagrams    BEFORE INSERT 
   ON TravelAgency.sysdiagrams
   FOR EACH ROW
   BEGIN
      SELECT tt_TravelAgency.sysdiagrams.NEXTVAL INTO :NEW.diagram_id
        FROM DUAL;
   END;
/


CREATE OR REPLACE FUNCTION TravelAgency.sp_upgraddiagrams
RETURN NUMBER
AS

BEGIN

   IF utils.object_id(N'dbo.sysdiagrams') IS NOT NULL THEN
    RETURN 0;
   END IF;
   DELETE FROM TravelAgency.sysdiagrams;
   -- we may change it to varbinary(85)
   /* Add this if we need to have some form of extended properties for diagrams */
   /*
   		IF OBJECT_ID(N'dbo.sysdiagram_properties') IS NULL
   		BEGIN
   			CREATE TABLE dbo.sysdiagram_properties
   			(
   				diagram_id int,
   				name sysname,
   				value varbinary(max) NOT NULL
   			)
   		END
   		*/
   IF utils.object_id(N'dbo.dtproperties') IS NOT NULL THEN
    
   BEGIN
      INSERT INTO TravelAgency.sysdiagrams
        ( name, principal_id, version, definition )
        ( SELECT UTILS.CONVERT_TO_VARCHAR2(dgnm.uvalue,128) ,
                 DATABASE_PRINCIPAL_ID(N'dbo' 
                 ) ,-- will change to the sid of sa

                 0 ,-- zero for old format, dgdef.[version],

                 dgdef.lvalue 
          FROM TravelAgency.dtproperties dgnm
                 JOIN TravelAgency.dtproperties dggd   ON dggd.property = 'DtgSchemaGUID'
                 AND dggd.objectid = dgnm.objectid
                 JOIN TravelAgency.dtproperties dgdef   ON dgdef.property = 'DtgSchemaDATA'
                 AND dgdef.objectid = dgnm.objectid
           WHERE  dgnm.property = 'DtgSchemaNAME'
                    AND dggd.uvalue LIKE N'_EA3E6268-D998-11CE-9454-00AA00A3F36E_' );
      RETURN 2;
   
   END;
   END IF;
   RETURN 1;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON sp_upgraddiagrams TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE UpdateCountries
(
  v_country IN NVARCHAR2,
  v_visa IN NUMBER
)
AS

BEGIN

   UPDATE Countries
      SET visa = v_visa
    WHERE  country = v_country;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON UpdateCountries TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE UpdateOperator
(
  v_name IN NVARCHAR2,
  v_phoneNumber IN NVARCHAR2
)
AS

BEGIN

   UPDATE Touroperators
      SET phoneNumber = v_phoneNumber
    WHERE  NAME = v_name;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON UpdateOperator TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE UpdateOrder
(
  v_idVoucher IN NUMBER,
  v_customer IN NVARCHAR2,
  v_pay IN NUMBER
)
AS

BEGIN

   UPDATE Orders
      SET idVoucher = v_idVoucher,
          pay = v_pay
    WHERE  customer = v_customer;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON UpdateOrder TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE UpdateTour
(
  v_idTours IN NUMBER,
  v_idCountry IN NUMBER,
  v_idOperator IN NUMBER,
  v_tourName IN NVARCHAR2,
  v_descr IN NVARCHAR2
)
AS

BEGIN

   UPDATE Tours
      SET idCountry = v_idCountry,
          idOperator = v_idOperator,
          descr = v_descr,
          tourName = v_tourName
    WHERE  idTours = v_idTours;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON UpdateTour TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE UpdateVoucher
(
  v_idTour IN NUMBER,
  v_voucherName IN NVARCHAR2,
  v_descr IN NVARCHAR2,
  v_fullPrice IN NUMBER,
  v_price IN NUMBER,
  v_numberOfPeople IN NUMBER,
  v_nutrition IN NUMBER,
  v_accommodation IN NUMBER,
  v_hot IN NUMBER,
  v_discount IN NUMBER
)
AS

BEGIN

   UPDATE Vouchers
      SET idTour = v_idTour,
          descr = v_descr,
          price = v_price,
          numberOfPeople = v_numberOfPeople,
          nutrition = v_nutrition,
          accommodation = v_accommodation,
          hot = v_hot,
          discount = v_discount
    WHERE  voucherName = v_voucherName;

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON UpdateVoucher TO ROLE_lab6_2;
CREATE OR REPLACE PROCEDURE Us_GetOrdersAUTHID DEFINER
AS
   v_cursor SYS_REFCURSOR;

BEGIN

   OPEN  v_cursor FOR
      SELECT * 
        FROM Orders  ;
      DBMS_SQL.RETURN_RESULT(v_cursor);

EXCEPTION WHEN OTHERS THEN utils.handleerror(SQLCODE,SQLERRM);
END;
/
GRANT ALL ON Us_GetOrders TO ROLE_lab6_2;
CREATE OR REPLACE TRIGGER UpdatePrice
   AFTER INSERT
   ON Vouchers
   FOR EACH ROW
DECLARE
   v_cursor SYS_REFCURSOR;

BEGIN
   BEGIN
      
      BEGIN
         UPDATE Vouchers
            SET price = price * 1.1;
         utils.commit_transaction;
      
      END;
   EXCEPTION
      WHEN OTHERS THEN
   
   BEGIN
      ROLLBACK;
      utils.resetTrancount;
      OPEN  v_cursor FOR
         SELECT ('Error') ErrorMessage  
           FROM DUAL  ;
         DBMS_SQL.RETURN_RESULT(v_cursor);
   
   END;END;

END;
/

set define on
prompt connecting to TravelAgency
alter session set current_schema=TravelAgency;
set define off
PROMPT Creating Foreign Key Constraint FK__Tours__idCountry__3D5E1FD2 on table Countries...
ALTER TABLE Tours
ADD CONSTRAINT FK__Tours__idCountry__3D5E1FD2 FOREIGN KEY
(
  idCountry
)
REFERENCES Countries
(
  idCountry
)
ENABLE
;

PROMPT Creating Foreign Key Constraint Country_ID_FK on table world_countries...
ALTER TABLE Countries
ADD CONSTRAINT Country_ID_FK FOREIGN KEY
(
  CountryMap
)
REFERENCES world_countries
(
  ogr_fid
)
ENABLE
;

PROMPT Creating Foreign Key Constraint FK__Tours__idOperato__3E52440B on table Touroperators...
ALTER TABLE Tours
ADD CONSTRAINT FK__Tours__idOperato__3E52440B FOREIGN KEY
(
  idOperator
)
REFERENCES Touroperators
(
  idOperator
)
ENABLE
;

PROMPT Creating Foreign Key Constraint FK__Orders__idVouche__440B1D61 on table Vouchers...
ALTER TABLE Orders
ADD CONSTRAINT FK__Orders__idVouche__440B1D61 FOREIGN KEY
(
  idVoucher
)
REFERENCES Vouchers
(
  idVoucher
)
ENABLE
;

PROMPT Creating Foreign Key Constraint FK__Vouchers__idTour__412EB0B6 on table Tours...
ALTER TABLE Vouchers
ADD CONSTRAINT FK__Vouchers__idTour__412EB0B6 FOREIGN KEY
(
  idTour
)
REFERENCES Tours
(
  idTours
)
ENABLE
;

ALTER VIEW CustomerVoucher COMPILE;

ALTER VIEW NumberPeopleTour COMPILE;

ALTER VIEW CuctomerOperator COMPILE;

spool off;

COMMIT;

